diff --git a/src/Makefile b/src/Makefile
index bcdbd9588a..82c5a3940f 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -16,13 +16,14 @@ SUBDIRS = \
 	common \
 	port \
 	timezone \
+	interfaces \
 	backend \
 	backend/utils/mb/conversion_procs \
 	backend/snowball \
 	include \
-	interfaces \
 	backend/replication/libpqwalreceiver \
 	backend/replication/pgoutput \
+	backend/storage/lmgr/libpqgddcheckremote \
 	fe_utils \
 	bin \
 	pl \
diff --git a/src/backend/Makefile b/src/backend/Makefile
index b03d5e510f..76336615a1 100644
--- a/src/backend/Makefile
+++ b/src/backend/Makefile
@@ -51,6 +51,8 @@ ifeq ($(with_systemd),yes)
 LIBS += -lsystemd
 endif
 
+LIBS += ../../src/interfaces/libpq/libpq.a
+
 ##########################################################################
 
 all: submake-libpgport submake-catalog-headers submake-utils-headers postgres $(POSTGRES_IMP)
diff --git a/src/backend/storage/lmgr/Makefile b/src/backend/storage/lmgr/Makefile
index 8179f6dceb..718b7d0f76 100644
--- a/src/backend/storage/lmgr/Makefile
+++ b/src/backend/storage/lmgr/Makefile
@@ -15,6 +15,7 @@ include $(top_builddir)/src/Makefile.global
 OBJS = lmgr.o lock.o proc.o deadlock.o lwlock.o lwlocknames.o spin.o \
 	s_lock.o predicate.o condition_variable.o
 
+
 include $(top_srcdir)/src/backend/common.mk
 
 ifdef TAS
diff --git a/src/backend/storage/lmgr/deadlock.c b/src/backend/storage/lmgr/deadlock.c
index f17ef9377a..0eef237dfd 100644
--- a/src/backend/storage/lmgr/deadlock.c
+++ b/src/backend/storage/lmgr/deadlock.c
@@ -6,11 +6,10 @@
  * See src/backend/storage/lmgr/README for a description of the deadlock
  * detection and resolution algorithms.
  *
- *
+ * Portions Copyright (c) 2020, 2ndQuadrant Ltd.,
  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
- *
  * IDENTIFICATION
  *	  src/backend/storage/lmgr/deadlock.c
  *
@@ -21,28 +20,173 @@
  *	RememberSimpleDeadLock()
  *	InitDeadLockChecking()
  *
+ *  DeadLockCheck() has additional return value.  See proc.c for the handling
+ *  of this value.
+ *
+ *  Additional interface for global deadlock detection:
+ *
+ *  get_database_system_id()
+ *  locktagTypeName()
+ *  GlobalDeadlockCheck()
+ *  GlobalDeadlockCheckRemote()
+ *  GetDeadLockInfo()
+ *
+ * SQL functions for global deadlock detection:
+ *
+ *  pg_global_deadlock_check_from_remote()
+ *  pg_global_deadlock_recheck_from_remote()
+ *  pg_global_deadlock_check_describe_backend()
+ *	
  *-------------------------------------------------------------------------
  */
+
+#define	GDD_DEBUG
+#undef	GDD_DEBUG
+
 #include "postgres.h"
 
+#include <unistd.h>
+
+#include "../interfaces/libpq/libpq-fe.h"
+#include "catalog/pg_control.h"
+#include "catalog/pg_type_d.h"
+#include "common/controldata_utils.h"
+#include "funcapi.h"
 #include "miscadmin.h"
 #include "pg_trace.h"
 #include "pgstat.h"
+#include "postmaster/postmaster.h"
+#include "storage/global_deadlock.h"
 #include "storage/lmgr.h"
 #include "storage/proc.h"
+#include "utils/fmgrprotos.h"
 #include "utils/memutils.h"
 
+/*
+ * DeadlockCheckMode controls the behavior of DeadLockCheck() and DeadLockCheck_int().
+ * 
+ * DLCMODE_LOCAL:
+ *		Used when invoked by local proc.c.   If hard deadlock is detected, then
+ *		it is returned to proc.c to terminate the backend.
+ *		If only external lock is found, found deadlock informatin (wait-for-graph,
+ *		also called external lock path) are all backed up for further global
+ *		deadlock check.
+ *		Then all the exernal lick path is examined by visiting downstream database
+ *		using GlobalDeadlockCheck() or GlobalDeadlockCheck_int().
+ *
+ * DLCMODE_GLOBAL_NEW:
+ *		Indicates DeadLockCheck() or DeadLockCheck_int() is called by
+ *		pg_global_deadlock_check_from_remote() SQL function.  This SQL function
+ *		is invked by upstream database through GlobalDeadlockCheck_int().
+ *		This also indicates this databaes is visited for the first time in
+ *		global external lock path.
+ *		In this case, local hard deadlock found by DeadLockCheck_int() is
+ *		ignored (should be take care of by local DeadLockCheck()).
+ *		Only wait-for-graphs terminating with external lock (external lock paths) are chosen.
+ *		Each of these external lock paths are examined further by GlobalDeadlockCheck_int()
+ *		for further downstream databases.
+ *
+ * DLCMODE_GLOBAL_AGAIN:
+ *		Indicates DeadLockCheck() or DeadLockCheck_int() is called by
+ *		pg_global_deadlock_check_from_remote() SQL function, as above.
+ *		This also indicate that this database has been visited in the current chain
+ *		of external lock path but is not the database of the origin of the path.
+ *		In this case, if DeadLockCheck() or DeadLockCheck_int() discovers local or
+ *		global deadlock originating such database visited bofore, this is partial
+ *		deadlock and will be ignored.   External lock path will be searched and
+ *		taken care of by GlobalDeadlockCheck_int() for further downstream database.
+ *		However, to avoid infinit global loop of the serch, external lock path
+ *		including ever-visited backend should be ignored.
+ *		Please note that external lock path include more than one of such databae.
+ *
+ * DLCMODE_GLOBAL_ORIGIN:
+ *		Indicates DeadLockCheck() or DeadLockCheck_int() is called buy
+ *		pg_global_deadlock_check_from_remote() SQL function, as above.
+ *		This also indicates that this databaes is the origin database which started
+ *		this external lock path.
+ *		In this case, deadlock candidate is recorded and returned to upstream databases.
+ *		Please note that all the deadlock candidates are recorded.
+ *		Also, further external lock path is searched and recorded for further downstream
+ *		deadlock search, done by GlobalDeadlockCheck_int().
+ *		In searching external lock path, we need to take into accoun that another edge
+ *		However, to avoid infinit global loop of the serch, external lock path
+ *		including ever-visited backend should be ignored as in the case of DLCMODE_GLOBAL_AGAIN.
+ *		in the exernal lock path may be of the origin.
+ *
+ * These DeadlockCheckMode will be set by globalDeadlockCheckMode() by giving gloabl wait-for-graph
+ * described below.
+ *
+ * Deadlock detection basically uses LOCK component.  Other PG lock components, such as LWlock,
+ * spinlock and semaphore are building blocks of LOCK component.
+ *
+ * As described in many transaction textbook, deadlock can be detected by examining if there's any
+ * cycle in a graph called wait-for-graph.   Wait-for-graph describes block and wait relationship
+ * between PG backends.
+ *
+ * In local deadlock check, when a backend cannot acquire a lock within deadlock_timeout interval,
+ * DeadLockCheck() is called by proc.c module.  Before calling, caller must acquire all low level
+ * locks (LWLock) so that we can can LOCK and PGPROC stablly.
+ *
+ * When a cycle is found in the wait-for-graph, we return that deadlock is detected.   In this case,
+ * caller can terminate this process to resolve the deadlock situation.
+ *
+ * In the case of global deadlock, this block-and-wait relationship spans across different databases
+ * and we need to scan all ths block-and-wait chain across databases to find a cycle in such
+ * global wait-for-graph.
+ *
+ * To represent this remote relationship, new LOCK type, called EXTERNAL LOCK, was added.
+ * External lock represents waitor of the lock is waiting for remote transaction to complete.
+ * Becuase actual lock holder is not in the local database, this is also held by the backend
+ * waiting for it.
+ *
+ * Applicaiton of remote transaction, such as FDW remote transaction, should use lock.h
+ * API to acquire and wait an EXTERNAL LOCK.
+ *
+ * In the local deadlock check (DeadLockCheck()), when we find processes waiting for EXTERNAL LOCK,
+ * waiting-for-graph (in the form of DADLOCK_INFO), is backed up because there could be more than
+ * one candidate of such wait-for-graph segment.
+ *
+ * When no local deadlock was detected and wait-for-graph segment going out to remote transactions
+ * were found,  DeadLockCheck() returns DS_EXTERNAL_LOCK status.    When the caller receives this
+ * status, it can release all the LWLocks and then should call GlobalDeadlockCheck().
+ *
+ * GlobalDeadlockCheck() runs without such big set of locks so that it take long to examine
+ * global wait-for-graph spanning across many databases.
+ *
+ * Code between #if 0 ... #endif is just for future additional code.   Will be removed when the test
+ * has been done.
+ */
 
 /*
- * One edge in the waits-for graph.
- *
- * waiter and blocker may or may not be members of a lock group, but if either
- * is, it will be the leader rather than any other member of the lock group.
- * The group leaders act as representatives of the whole group even though
- * those particular processes need not be waiting at all.  There will be at
- * least one member of the waiter's lock group on the wait queue for the given
- * lock, maybe more.
+ * See above for definition of the mode.
+ *
+ * This mode controls behavior of DeadLockCheck().
  */
+typedef enum DeadlockCheckMode
+{
+	DLCMODE_LOCAL,				/* Invoked locally                                          */
+	DLCMODE_GLOBAL_NEW,			/* Part of global deadlock detection.                       */
+								/* 		First visit to the database in External Lock path   */
+	DLCMODE_GLOBAL_AGAIN,		/* Part of global deadlock detection.                       */
+								/* 		Visited this database in the past but it is         */
+								/* 		not the origin.                                     */
+	DLCMODE_GLOBAL_ORIGIN,		/* Part of global deadlock detection.                       */
+								/*		Invoked in the origin database                      */
+	DLCMODE_ERROR
+} DeadlockCheckMode;
+
+static DeadlockCheckMode	deadlockCheckMode;
+
+/*
+* One edge in the waits-for graph.
+*
+* waiter and blocker may or may not be members of a lock group, but if either
+* is, it will be the leader rather than any other member of the lock group.
+* The group leaders act as representatives of the whole group even though
+* those particular processes need not be waiting at all.  There will be at
+* least one member of the waiter's lock group on the wait queue for the given
+* lock, maybe more.
+*/
 typedef struct
 {
 	PGPROC	   *waiter;			/* the leader of the waiting lock group */
@@ -61,38 +205,107 @@ typedef struct
 } WAIT_ORDER;
 
 /*
- * Information saved about each edge in a detected deadlock cycle.  This
- * is used to print a diagnostic message upon failure.
+ * The following structure is used to backup more than one candidate of
+ * global wait-for-graph segment.
  *
- * Note: because we want to examine this info after releasing the lock
- * manager's partition locks, we can't just store LOCK and PGPROC pointers;
- * we must extract out all the info we want to be able to print.
+ * Unlike other objects used in DeadLockCheck(), DEADLOCK_INFO_BUP object must be
+ * allocated dynamically when EXTERNAL LOCK is found in waiting lock of the backend
+ * because we cannot forcast maximum number of such segments in advance.
  */
-typedef struct
+typedef struct DEADLOCK_INFO_BUP
 {
-	LOCKTAG		locktag;		/* ID of awaited lock object */
-	LOCKMODE	lockmode;		/* type of lock we're waiting for */
-	int			pid;			/* PID of blocked backend */
-} DEADLOCK_INFO;
-
-
-static bool DeadLockCheckRecurse(PGPROC *proc);
-static int	TestConfiguration(PGPROC *startProc);
-static bool FindLockCycle(PGPROC *checkProc,
-						  EDGE *softEdges, int *nSoftEdges);
-static bool FindLockCycleRecurse(PGPROC *checkProc, int depth,
-								 EDGE *softEdges, int *nSoftEdges);
-static bool FindLockCycleRecurseMember(PGPROC *checkProc,
-									   PGPROC *checkProcLeader,
-									   int depth, EDGE *softEdges, int *nSoftEdges);
+	struct DEADLOCK_INFO_BUP *next;
+	int				nDeadlock_info;
+	DeadLockState	state;
+	DEADLOCK_INFO	deadlock_info[0];
+} DEADLOCK_INFO_BUP;
+
+DEADLOCK_INFO_BUP	*deadlock_info_bup_head;	/* Head of the queue */
+DEADLOCK_INFO_BUP	*deadlock_info_bup_tail;	/* Tail of the queue */
+
+
+/*
+ * Functions for local deadlock detection and and wait-for-graph extraction
+ */
+static DeadLockState DeadLockCheckRecurse(PGPROC *proc);
+static int          TestConfiguration(PGPROC *startProc);
+static DeadLockState FindLockCycle(PGPROC *checkProc,
+							   EDGE *softEdges, int *nSoftEdges);
+static DeadLockState FindLockCycleRecurse(PGPROC *checkProc, int depth,
+							   EDGE *softEdges, int *nSoftEdges);
+static DeadLockState FindLockCycleRecurseMember(PGPROC *checkProc,
+							   PGPROC *checkProcLeader,
+							   int depth, EDGE *softEdges, int *nSoftEdges);
+
 static bool ExpandConstraints(EDGE *constraints, int nConstraints);
 static bool TopoSort(LOCK *lock, EDGE *constraints, int nConstraints,
-					 PGPROC **ordering);
+				 PGPROC **ordering);
 
+static LOCAL_WFG *BuildLocalWfG(PGPROC *origin, DEADLOCK_INFO_BUP *info);
+static void hold_all_lockline(void);
+static void release_all_lockline(void);
+static void release_all_lockline(void);
 #ifdef DEBUG_DEADLOCK
 static void PrintLockQueue(LOCK *lock, const char *info);
+
+/*
+ * Functions for global lock detection
+ */
 #endif
 
+#define WORKER_NAME	"pg_gdd_check_worker"
+
+static DeadLockState DeadLockCheck_int(PGPROC *proc);
+static int GlobalDeadlockCheckRemote(LOCAL_WFG *local_wfg, GLOBAL_WFG *global_wfg, RETURNED_WFG **returning_wfg);
+static DeadLockState GlobalDeadlockCheck_int(PGPROC *proc, GLOBAL_WFG *global_wfg, RETURNED_WFG **rv);
+static DeadlockCheckMode globalDeadlockCheckMode(GLOBAL_WFG *global_wfg);
+static GLOBAL_WFG *addToGlobalWfG(GLOBAL_WFG *g_wfg, LOCAL_WFG *local_wfg);
+static void clean_deadlock_info_bup_recursive(DEADLOCK_INFO_BUP *info);
+static void clean_deadlock_info_bup(void);
+static bool check_local_wfg_is_stable(LOCAL_WFG *localWfG);
+static void backup_deadlock_info(DeadLockState state);
+static void free_returned_wfg(RETURNED_WFG *returned_wfg);
+static RETURNED_WFG *add_returned_wfg(RETURNED_WFG *dest, RETURNED_WFG *src, bool clean_opt);
+static RETURNED_WFG *addGlobalWfgToReturnedWfg(RETURNED_WFG *returned_wfg, DeadLockState state, GLOBAL_WFG *global_wfg);
+static RETURNED_WFG *globalDeadlockCheckFromRemote(char *global_wfg_text, DeadLockState *state);
+static void free_local_wfg(LOCAL_WFG *local_wfg);
+static PGPROC *find_pgproc(int pid);
+static PGPROC *find_pgproc_pgprocno(int pgprocno);
+static LOCAL_WFG *copy_local_wfg(LOCAL_WFG *l_wfg);
+static GLOBAL_WFG *copy_global_wfg(GLOBAL_WFG *g_wfg);
+static bool external_lock_already_in_gwfg(GLOBAL_WFG *global_wfg, DEADLOCK_INFO_BUP *dl_info_bup);
+static void *gdd_repalloc(void *pointer, Size size);
+static void DeadLockReport_int(void) pg_attribute_noreturn();
+static void GlobalDeadlockReport_int(void) pg_attribute_noreturn();
+static void	add_backend_activities_local_wfg(LOCAL_WFG *local_wfg);
+#ifdef GDD_DEBUG
+void free_global_wfg(GLOBAL_WFG *global_wfg);
+static void print_global_wfg(StringInfo out, GLOBAL_WFG *g_wfg);
+static void print_local_wfg(StringInfo out, LOCAL_WFG *l_wfg, int idx, int total);
+static void print_deadlock_info(StringInfo out, DEADLOCK_INFO *info, int idx, int total);
+static void print_external_lock_info(StringInfo out, ExternalLockInfo *e);
+#endif /* GDD_DEBUG */
+static char *getAtoInt64(char *buf, int64 *value);
+static char *getAtoInt32(char *buf, int32 *value);
+static char *getAtoUint64(char *buf, uint64 *value);
+static char *getAtoUint32(char *buf, uint32 *value);
+static char *getAtoUint16(char *buf, uint16 *value);
+static char *getAtoUint8(char *buf, uint8 *value);
+static char *getHexaToInt(char *buf, int *value);
+static char *getHexaToLong(char *buf, long *value);
+static char *getString(char *buf, char **value);
+static char *findChar(char *buf, char c);
+static bool CloseScan(char *buf);
+static char *normalizeString(char *buf);
+static char *SerializeLocalWfG(LOCAL_WFG *local_wfg);
+static char *DeserializeLocalWfG(char *buf, LOCAL_WFG **local_wfg);
+static char *SerializeGlobalWfG(GLOBAL_WFG *g_wfg);
+static GLOBAL_WFG * DeserializeGlobalWfG(char *buf);
+
+#define Lock_PgprocArray()	LWLockAcquire(ProcArrayLock, LW_SHARED)
+#define Unlock_PgprocArray() LWLockRelease(ProcArrayLock)
+#define Lock_Pgproc(p)		LWLockAcquire(&(p)->backendLock, LW_SHARED)
+#define Unlock_Pgproc(p)	LWLockRelease(&(p)->backendLock)
 
 /*
  * Working space for the deadlock detector
@@ -102,6 +315,24 @@ static void PrintLockQueue(LOCK *lock, const char *info);
 static PGPROC **visitedProcs;	/* Array of visited procs */
 static int	nVisitedProcs;
 
+/* Workplace for global lock cycle search */
+static PGPROC **globalVisitedProcs = NULL;	/* Array of visited procs in global WfG */
+static int		nGlobalVisitedProcs = 0;
+
+/* Workplace for visited external locks */
+static ExternalLockInfo	**globalVisitedExternalLock = NULL;
+static int				  nGlobalVisitedExternalLock = 0;
+
+/*
+ * Additional visited proc list from global WfG
+ *
+ * In checking global cycle, we need process information of the origin of WfG.
+ * This is taken from the first member of visited Procs array.
+ */
+static int	 			visitedOriginPid = 0;			/* pid */
+static int	 			visitedOriginPgprocno = 0;		/* pgprocno */
+static TransactionId	visitedOriginTxid = 0;			/* transaction id */
+
 /* Workspace for TopoSort */
 static PGPROC **topoProcs;		/* Array of not-yet-output procs */
 static int *beforeConstraints;	/* Counts of remaining before-constraints */
@@ -127,6 +358,30 @@ static int	nDeadlockDetails;
 /* PGPROC pointer of any blocking autovacuum worker found */
 static PGPROC *blocking_autovacuum_proc = NULL;
 
+/* Database System Identifier of the current database */
+static uint64 my_database_system_identifier = 0;
+
+/* Global wait-for-graph for deadlock report */
+static GLOBAL_WFG *global_deadlock_info = NULL;
+
+/* Entry point for remote database WfG check */
+PGDLLIMPORT gdd_check_fn	*pg_gdd_check_func = NULL;
+
+#ifdef GDD_DEBUG
+#define	GDD_ARRAY_MAX 128
+#endif /* GDD_DEBUG */
+
+/* Macros for serialize/deserialize WfG */
+#define FindChar(b, c) do{b = findChar(b, c); if (b == NULL) return NULL;}while(0)
+#define GetHexaToInt(b, v) do{b = getHexaToInt(b, v); if (b == NULL) return NULL;}while(0)
+#define GetHexaToLong(b, v) do{b = getHexaToLong(b, v); if (b == NULL) return NULL;}while(0)
+#define GetAtoInt64(b, v) do{b = getAtoInt64(b, v); if (b == NULL) return NULL;}while(0)
+#define GetAtoInt32(b, v) do{b = getAtoInt32(b, v); if (b == NULL) return NULL;}while(0)
+#define GetAtoUint64(b, v) do{b = getAtoUint64(b, v); if (b == NULL) return NULL;}while(0)
+#define GetAtoUint32(b, v) do{b = getAtoUint32(b, v); if (b == NULL) return NULL;}while(0)
+#define GetAtoUint16(b, v) do{b = getAtoUint16(b, v); if (b == NULL) return NULL;}while(0)
+#define GetAtoUint8(b, v) do{b = getAtoUint8(b, v); if (b == NULL) return NULL;}while(0)
+#define GetString(b, v) do{b = getString(b, v); if (b == NULL) return NULL;}while(0)
 
 /*
  * InitDeadLockChecking -- initialize deadlock checker during backend startup
@@ -195,6 +450,8 @@ InitDeadLockChecking(void)
 	possibleConstraints =
 		(EDGE *) palloc(maxPossibleConstraints * sizeof(EDGE));
 
+	deadlock_info_bup_head = deadlock_info_bup_tail = NULL;
+
 	MemoryContextSwitchTo(oldcxt);
 }
 
@@ -212,25 +469,59 @@ InitDeadLockChecking(void)
  * subsequent printing by DeadLockReport().  That activity is separate
  * because (a) we don't want to do it while holding all those LWLocks,
  * and (b) we are typically invoked inside a signal handler.
+ *
+ * When DS_EXTERNAL_LOCK is returned from this function, it means there
+ * are no local deadlock but there are candidate wait-for-graph segment
+ * going out to a remote transaction.
+ *
+ * In this case, the caller must release all the low-level LWlock for
+ * LOCK lockline and call GlobalDeadlochCheck().
+ *
+ * These two functions are separated because the caller (proc.c) must
+ * terminate the backend when DS_HARD_DEADLOCK is holding all the
+ * low level locks acquired.
  */
 DeadLockState
 DeadLockCheck(PGPROC *proc)
+{
+	DeadLockState	status;
+
+	global_deadlock_info = NULL;
+
+	deadlockCheckMode = globalDeadlockCheckMode(NULL);
+
+	status = DeadLockCheck_int(proc);
+	if (status == DS_DEADLOCK_INFO)
+		status = DS_EXTERNAL_LOCK;
+	return status;
+}
+
+static DeadLockState
+DeadLockCheck_int(PGPROC *proc)
 {
 	int			i,
 				j;
+	DeadLockState	status;
 
 	/* Initialize to "no constraints" */
 	nCurConstraints = 0;
 	nPossibleConstraints = 0;
 	nWaitOrders = 0;
 
+	/* Initialize deadlock info storage */
+	deadlock_info_bup_head = deadlock_info_bup_tail = NULL;
+
 	/* Initialize to not blocked by an autovacuum worker */
 	blocking_autovacuum_proc = NULL;
 
 	/* Search for deadlocks and possible fixes */
-	if (DeadLockCheckRecurse(proc))
+	status = DeadLockCheckRecurse(proc);
+
+	if (status == DS_HARD_DEADLOCK)
 	{
 		/*
+		 * This status is only for deadlockCheckMode == DLCMODE_LOCAL.
+		 *
 		 * Call FindLockCycle one more time, to record the correct
 		 * deadlockDetails[] for the basic state with no rearrangements.
 		 */
@@ -242,9 +533,14 @@ DeadLockCheck(PGPROC *proc)
 		if (!FindLockCycle(proc, possibleConstraints, &nSoftEdges))
 			elog(FATAL, "deadlock seems to have disappeared");
 
-		return DS_HARD_DEADLOCK;	/* cannot find a non-deadlocked state */
+		return status;	/* cannot find a non-deadlocked state */
 	}
-
+	if (status == DS_DEADLOCK_INFO)
+		/*
+		 * This status is only for deadlockCheckMode == DLCMODE_GLOBAL_xxx
+		 */
+		return status;
+	
 	/* Apply any needed rearrangements of wait queues */
 	for (i = 0; i < nWaitOrders; i++)
 	{
@@ -310,22 +606,32 @@ GetBlockingAutoVacuumPgproc(void)
  * Returns true if no solution exists.  Returns false if a deadlock-free
  * state is attainable, in which case waitOrders[] shows the required
  * rearrangements of lock wait queues (if any).
+ *
+ * Return value:
+ *	DS_NO_DEADLOCK: no hard deadlock or not waiting for external lock
+ *  DS_HARD_DEADLOCK: local deadlock detected
+ *  DS_EXTERNAL_LOCK: exrernal lock detected, need to do global deadlock check.
  */
-static bool
+static DeadLockState
 DeadLockCheckRecurse(PGPROC *proc)
 {
 	int			nEdges;
 	int			oldPossibleConstraints;
 	bool		savedList;
 	int			i;
+	DeadLockState	status = DS_NOT_YET_CHECKED;
 
 	nEdges = TestConfiguration(proc);
+	if (nEdges == -2)		/* K.Suzuki external lock was detected. */
+		return DS_DEADLOCK_INFO;
+	if (nEdges == -1)
+		return DS_HARD_DEADLOCK;	/* hard deadlock --- no solution */
 	if (nEdges < 0)
-		return true;			/* hard deadlock --- no solution */
+		elog(FATAL, "inconsistent results during deadlock check");
 	if (nEdges == 0)
-		return false;			/* good configuration found */
+		return DS_NO_DEADLOCK;		/* good configuration found */
 	if (nCurConstraints >= maxCurConstraints)
-		return true;			/* out of room for active constraints? */
+		return DS_HARD_DEADLOCK;	/* out of room for active constraints? */
 	oldPossibleConstraints = nPossibleConstraints;
 	if (nPossibleConstraints + nEdges + MaxBackends <= maxPossibleConstraints)
 	{
@@ -353,13 +659,14 @@ DeadLockCheckRecurse(PGPROC *proc)
 		curConstraints[nCurConstraints] =
 			possibleConstraints[oldPossibleConstraints + i];
 		nCurConstraints++;
-		if (!DeadLockCheckRecurse(proc))
-			return false;		/* found a valid solution! */
+		status = DeadLockCheckRecurse(proc);
+		if (status != DS_HARD_DEADLOCK && status != DS_DEADLOCK_INFO)
+			return status;		/* found a valid solution! -- no deadlock */
 		/* give up on that added constraint, try again */
 		nCurConstraints--;
 	}
 	nPossibleConstraints = oldPossibleConstraints;
-	return true;				/* no solution found */
+	return status;				/* no solution found */
 }
 
 
@@ -369,6 +676,8 @@ DeadLockCheckRecurse(PGPROC *proc)
  * Returns:
  *		0: the configuration is good (no deadlocks)
  *	   -1: the configuration has a hard deadlock or is not self-consistent
+ *     -2: external lock is included in the configuration
+ *			the configuration has an external lock at the edge of the graph.
  *		>0: the configuration has one or more soft deadlocks
  *
  * In the soft-deadlock case, one of the soft cycles is chosen arbitrarily
@@ -384,6 +693,7 @@ TestConfiguration(PGPROC *startProc)
 	EDGE	   *softEdges = possibleConstraints + nPossibleConstraints;
 	int			nSoftEdges;
 	int			i;
+	DeadLockState	state;
 
 	/*
 	 * Make sure we have room for FindLockCycle's output.
@@ -405,23 +715,46 @@ TestConfiguration(PGPROC *startProc)
 	 */
 	for (i = 0; i < nCurConstraints; i++)
 	{
-		if (FindLockCycle(curConstraints[i].waiter, softEdges, &nSoftEdges))
+
+		state = FindLockCycle(curConstraints[i].waiter, softEdges, &nSoftEdges);
+		if (state)
 		{
 			if (nSoftEdges == 0)
-				return -1;		/* hard deadlock detected */
+			{
+				if (state == DS_HARD_DEADLOCK)
+					return -1;		/* hard deadlock detected */
+				else if (state == DS_DEADLOCK_INFO)
+					return -2;
+				else
+					elog(ERROR, "Inconsistent internal state in deadlock check (1), state: %d.", state);
+			}
 			softFound = nSoftEdges;
 		}
-		if (FindLockCycle(curConstraints[i].blocker, softEdges, &nSoftEdges))
+		state = FindLockCycle(curConstraints[i].blocker, softEdges, &nSoftEdges);
+		if (state)
 		{
 			if (nSoftEdges == 0)
-				return -1;		/* hard deadlock detected */
+			{
+				if (state == DS_HARD_DEADLOCK)
+					return -1;		/* hard deadlock detected */
+				else if (state == DS_EXTERNAL_LOCK)
+					return -2;
+				else
+					elog(ERROR, "Inconsistent internal state in deadlock check (2), state: %d.", state);
+			}
 			softFound = nSoftEdges;
 		}
 	}
-	if (FindLockCycle(startProc, softEdges, &nSoftEdges))
+	state = FindLockCycle(startProc, softEdges, &nSoftEdges);
+	if (state)
 	{
 		if (nSoftEdges == 0)
-			return -1;			/* hard deadlock detected */
+		{
+			if (state == DS_HARD_DEADLOCK)
+				return -1;		/* hard deadlock detected */
+			else if (state == DS_DEADLOCK_INFO)
+				return -2;
+		}
 		softFound = nSoftEdges;
 	}
 	return softFound;
@@ -444,8 +777,11 @@ TestConfiguration(PGPROC *startProc)
  * exist after wait queue rearrangement, the routine pays attention to the
  * table of hypothetical queue orders in waitOrders[].  These orders will
  * be believed in preference to the actual ordering seen in the locktable.
+ *
+ * Please take a look at the top of this file for deadlock check mode
+ * and related behavior.
  */
-static bool
+static DeadLockState
 FindLockCycle(PGPROC *checkProc,
 			  EDGE *softEdges,	/* output argument */
 			  int *nSoftEdges)	/* output argument */
@@ -456,14 +792,14 @@ FindLockCycle(PGPROC *checkProc,
 	return FindLockCycleRecurse(checkProc, 0, softEdges, nSoftEdges);
 }
 
-static bool
+static DeadLockState
 FindLockCycleRecurse(PGPROC *checkProc,
 					 int depth,
 					 EDGE *softEdges,	/* output argument */
 					 int *nSoftEdges)	/* output argument */
 {
-	int			i;
 	dlist_iter	iter;
+	DeadLockState	rv = DS_NO_DEADLOCK;
 
 	/*
 	 * If this process is a lock group member, check the leader instead. (Note
@@ -475,29 +811,81 @@ FindLockCycleRecurse(PGPROC *checkProc,
 	/*
 	 * Have we already seen this proc?
 	 */
-	for (i = 0; i < nVisitedProcs; i++)
+	if (deadlockCheckMode == DLCMODE_GLOBAL_ORIGIN)
+	{
+		if (visitedOriginPid == checkProc->pid &&
+			visitedOriginPgprocno == checkProc->pgprocno &&
+			visitedOriginTxid == checkProc->lxid)
+		{
+			/* Here, global wait-for-graph cycle has been found */
+
+			memset(&deadlockDetails[nDeadlockDetails].locktag, 0, sizeof(LOCKTAG));
+
+			if (checkProc->waitLock)
+			{
+				DEADLOCK_INFO	*info;
+					
+				nDeadlockDetails = depth + 1;
+				info = &deadlockDetails[nDeadlockDetails - 1];
+
+				info->locktag = checkProc->waitLock->tag;
+				info->lockmode = checkProc->waitLockMode;
+				info->pid = checkProc->pid;
+				info->pgprocno = checkProc->pgprocno;
+				info->txid = checkProc->lxid;
+				backup_deadlock_info(DS_HARD_DEADLOCK);
+				return DS_DEADLOCK_INFO;
+			}
+			else
+				return DS_NO_DEADLOCK;
+		}
+		else
+			return DS_NO_DEADLOCK;
+	}
+	if (deadlockCheckMode == DLCMODE_LOCAL)
 	{
-		if (visitedProcs[i] == checkProc)
+		/*
+		 * K.Suzuki: I kept original code not to forget this.   Howver, check is valid only
+		 * when ii == 0.  No other check look necessary.
+		 */
+		/*
+		 * Check if there's local wait-for-graph cycle.  This is done only at
+		 * LOCAL check mode.
+		 */
+#if 1
+		if (visitedProcs[0] == checkProc)
+		{
+			Assert(depth <= MaxBackends);
+
+			nDeadlockDetails = depth;
+			return DS_HARD_DEADLOCK;
+		}
+#else
+		for (i = 0; i < nVisitedProcs; i++)
 		{
-			/* If we return to starting point, we have a deadlock cycle */
-			if (i == 0)
+			if (visitedProcs[i] == checkProc)
 			{
+				/* If we return to starting point, we have a deadlock cycle */
+				if (i == 0)
+				{
+					/*
+					 * record total length of cycle --- outer levels will now fill
+					 * deadlockDetails[]
+					 */
+					Assert(depth <= MaxBackends);
+					nDeadlockDetails = depth;
+
+					return DS_HARD_DEADLOCK;
+				}
+
 				/*
-				 * record total length of cycle --- outer levels will now fill
-				 * deadlockDetails[]
+				 * Otherwise, we have a cycle but it does not include the start
+				 * point, so say "no deadlock".
 				 */
-				Assert(depth <= MaxBackends);
-				nDeadlockDetails = depth;
-
-				return true;
+				return DS_NO_DEADLOCK;
 			}
-
-			/*
-			 * Otherwise, we have a cycle but it does not include the start
-			 * point, so say "no deadlock".
-			 */
-			return false;
 		}
+#endif
 	}
 	/* Mark proc as seen */
 	Assert(nVisitedProcs < MaxBackends);
@@ -507,10 +895,49 @@ FindLockCycleRecurse(PGPROC *checkProc,
 	 * If the process is waiting, there is an outgoing waits-for edge to each
 	 * process that blocks it.
 	 */
-	if (checkProc->links.next != NULL && checkProc->waitLock != NULL &&
-		FindLockCycleRecurseMember(checkProc, checkProc, depth, softEdges,
-								   nSoftEdges))
-		return true;
+	if (checkProc->waitLock != NULL)
+	{
+		if (checkProc->waitLock->tag.locktag_type == LOCKTAG_EXTERNAL)
+		{
+			/*
+			 * Now we found EXTERNAL LOCK.  We need to check wait-for-graph
+			 * extending to the remote transaction specified by this EXTERNAL
+			 * LOCK.
+			 */
+
+			/* fill deadlockDetails[] */
+			DEADLOCK_INFO *info = &deadlockDetails[depth];
+
+			info->locktag = checkProc->waitLock->tag;
+			info->lockmode = checkProc->waitLockMode;
+			info->pid = checkProc->pid;
+			info->pgprocno = checkProc->pgprocno;
+			info->txid = checkProc->lxid;
+			/*
+			 * Different from LOCAL mode, we need to add external lock to DEADLOCK_INFO
+			 * for further anaoysis.
+			 */
+			nDeadlockDetails = depth + 1;
+
+			/*
+			 * Here we backup the deadlock info for safer place.  Deadlock info
+			 * area will be reused for further analysis.
+			 */
+			backup_deadlock_info(DS_EXTERNAL_LOCK);
+
+			return DS_DEADLOCK_INFO;
+		}
+	}
+	if (checkProc->links.next != NULL && checkProc->waitLock != NULL)
+
+	{
+		DeadLockState	state;
+
+		state = FindLockCycleRecurseMember(checkProc, checkProc, depth, softEdges, nSoftEdges);
+		if (state == DS_HARD_DEADLOCK)
+			return state;
+		rv = state;
+	}
 
 	/*
 	 * If the process is not waiting, there could still be outgoing waits-for
@@ -525,17 +952,22 @@ FindLockCycleRecurse(PGPROC *checkProc,
 
 		memberProc = dlist_container(PGPROC, lockGroupLink, iter.cur);
 
-		if (memberProc->links.next != NULL && memberProc->waitLock != NULL &&
-			memberProc != checkProc &&
-			FindLockCycleRecurseMember(memberProc, checkProc, depth, softEdges,
-									   nSoftEdges))
-			return true;
+		if (memberProc->links.next != NULL && memberProc->waitLock != NULL && memberProc != checkProc)
+		{
+			DeadLockState	state;
+
+			state = FindLockCycleRecurseMember(memberProc, checkProc, depth, softEdges, nSoftEdges);
+			if (state == DS_HARD_DEADLOCK)
+				return state;
+			if (state == DS_EXTERNAL_LOCK)
+				rv = DS_EXTERNAL_LOCK;
+		}
 	}
 
-	return false;
+	return rv;
 }
 
-static bool
+static DeadLockState
 FindLockCycleRecurseMember(PGPROC *checkProc,
 						   PGPROC *checkProcLeader,
 						   int depth,
@@ -554,6 +986,7 @@ FindLockCycleRecurseMember(PGPROC *checkProc,
 	int			i;
 	int			numLockModes,
 				lm;
+	DeadLockState	rv = DS_NO_DEADLOCK;
 
 	lockMethodTable = GetLocksMethodTable(lock);
 	numLockModes = lockMethodTable->numLockModes;
@@ -584,19 +1017,21 @@ FindLockCycleRecurseMember(PGPROC *checkProc,
 				if ((proclock->holdMask & LOCKBIT_ON(lm)) &&
 					(conflictMask & LOCKBIT_ON(lm)))
 				{
-					/* This proc hard-blocks checkProc */
-					if (FindLockCycleRecurse(proc, depth + 1,
-											 softEdges, nSoftEdges))
-					{
-						/* fill deadlockDetails[] */
-						DEADLOCK_INFO *info = &deadlockDetails[depth];
+					DeadLockState state;
+					/* fill deadlockDetails[] */
+					DEADLOCK_INFO *info = &deadlockDetails[depth];
 
-						info->locktag = lock->tag;
-						info->lockmode = checkProc->waitLockMode;
-						info->pid = checkProc->pid;
+					info->locktag = lock->tag;
+					info->lockmode = checkProc->waitLockMode;
+					info->pid = checkProc->pid;
+					info->pgprocno = checkProc->pgprocno;
+					info->txid = checkProc->lxid;
 
-						return true;
-					}
+					/* This proc hard-blocks checkProc */
+					state = FindLockCycleRecurse(proc, depth + 1, softEdges, nSoftEdges);
+					if (state == DS_HARD_DEADLOCK)
+						return state;
+					rv = state;
 
 					/*
 					 * No deadlock here, but see if this proc is an autovacuum
@@ -677,17 +1112,24 @@ FindLockCycleRecurseMember(PGPROC *checkProc,
 			/* Is there a conflict with this guy's request? */
 			if ((LOCKBIT_ON(proc->waitLockMode) & conflictMask) != 0)
 			{
-				/* This proc soft-blocks checkProc */
-				if (FindLockCycleRecurse(proc, depth + 1,
-										 softEdges, nSoftEdges))
-				{
-					/* fill deadlockDetails[] */
-					DEADLOCK_INFO *info = &deadlockDetails[depth];
+				DeadLockState state;
+				/* fill deadlockDetails[] */
+				DEADLOCK_INFO *info = &deadlockDetails[depth];
 
-					info->locktag = lock->tag;
-					info->lockmode = checkProc->waitLockMode;
-					info->pid = checkProc->pid;
+				info->locktag = lock->tag;
+				info->lockmode = checkProc->waitLockMode;
+				info->pid = checkProc->pid;
+				info->pgprocno = checkProc->pgprocno;
+				info->txid = checkProc->lxid;
 
+
+				/* This proc soft-blocks checkProc */
+				state = FindLockCycleRecurse(proc, depth + 1, softEdges, nSoftEdges);
+#if 0
+				if (state == DS_HARD_DEADLOCK || DS_EXTERNAL_LOCK)
+#endif
+				if (state == DS_HARD_DEADLOCK)
+				{
 					/*
 					 * Add this edge to the list of soft edges in the cycle
 					 */
@@ -696,8 +1138,10 @@ FindLockCycleRecurseMember(PGPROC *checkProc,
 					softEdges[*nSoftEdges].blocker = leader;
 					softEdges[*nSoftEdges].lock = lock;
 					(*nSoftEdges)++;
-					return true;
+					return state;
 				}
+				if (state == DS_DEADLOCK_INFO)
+					rv = DS_DEADLOCK_INFO;
 			}
 		}
 	}
@@ -750,17 +1194,24 @@ FindLockCycleRecurseMember(PGPROC *checkProc,
 			if ((LOCKBIT_ON(proc->waitLockMode) & conflictMask) != 0 &&
 				leader != checkProcLeader)
 			{
-				/* This proc soft-blocks checkProc */
-				if (FindLockCycleRecurse(proc, depth + 1,
-										 softEdges, nSoftEdges))
-				{
-					/* fill deadlockDetails[] */
-					DEADLOCK_INFO *info = &deadlockDetails[depth];
+				DeadLockState state;
+				/* fill deadlockDetails[] */
+				DEADLOCK_INFO *info = &deadlockDetails[depth];
+
+				info->locktag = lock->tag;
+				info->lockmode = checkProc->waitLockMode;
+				info->pid = checkProc->pid;
+				info->pgprocno = checkProc->pgprocno;
+				info->txid = checkProc->lxid;
 
-					info->locktag = lock->tag;
-					info->lockmode = checkProc->waitLockMode;
-					info->pid = checkProc->pid;
 
+				/* This proc soft-blocks checkProc */
+				state = FindLockCycleRecurse(proc, depth + 1, softEdges, nSoftEdges);
+#if 0
+				if (state == DS_HARD_DEADLOCK || state == DS_EXTERNAL_LOCK)
+#endif
+				if (state == DS_HARD_DEADLOCK)
+				{
 					/*
 					 * Add this edge to the list of soft edges in the cycle
 					 */
@@ -769,8 +1220,10 @@ FindLockCycleRecurseMember(PGPROC *checkProc,
 					softEdges[*nSoftEdges].blocker = leader;
 					softEdges[*nSoftEdges].lock = lock;
 					(*nSoftEdges)++;
-					return true;
+					return state;
 				}
+				if (state == DS_DEADLOCK_INFO)
+					rv = DS_DEADLOCK_INFO;
 			}
 
 			proc = (PGPROC *) proc->links.next;
@@ -778,9 +1231,9 @@ FindLockCycleRecurseMember(PGPROC *checkProc,
 	}
 
 	/*
-	 * No conflict detected here.
+	 * No conflict detected or EXTERNAL LOCK found.
 	 */
-	return false;
+	return rv;
 }
 
 
@@ -1081,6 +1534,15 @@ PrintLockQueue(LOCK *lock, const char *info)
  */
 void
 DeadLockReport(void)
+{
+	if (global_deadlock_info == NULL)
+		DeadLockReport_int();
+	else
+		GlobalDeadlockReport_int();
+}
+
+static void
+DeadLockReport_int(void)
 {
 	StringInfoData clientbuf;	/* errdetail for client */
 	StringInfoData logbuf;		/* errdetail for server log */
@@ -1168,3 +1630,1814 @@ RememberSimpleDeadLock(PGPROC *proc1,
 	info->pid = proc2->pid;
 	nDeadlockDetails = 2;
 }
+
+/*
+ * Build LOCAL_WFG from DADLOCK_INFO_BUP.   If Origin flag is specified,
+ * then backend information of originating process will be added too.
+ *
+ * Resultant LOCAL_WFG will be used to build GLOBAL_WFG to be sent to
+ * remote backend for global deadlock check.
+ */
+static LOCAL_WFG *
+BuildLocalWfG(PGPROC *origin, DEADLOCK_INFO_BUP *info)
+{
+	int			 ii;
+	LOCAL_WFG	*local_wfg;
+
+	local_wfg = (LOCAL_WFG *)palloc0(sizeof(LOCAL_WFG));
+	if (deadlockDetails[nDeadlockDetails - 1].locktag.locktag_type == LOCKTAG_EXTERNAL)
+		local_wfg->local_wfg_flag |= WfG_HAS_EXTERNAL_LOCK;
+	local_wfg->database_system_identifier = get_database_system_id();
+	if (origin)
+	{
+		Assert(nVisitedProcs > 0);
+		local_wfg->local_wfg_flag |= WfG_HAS_VISITED_PROC;
+		local_wfg->visitedProcPid = visitedProcs[0]->pid;
+		local_wfg->visitedProcPgprocno = visitedProcs[0]->pgprocno;
+		local_wfg->visitedProcLxid = visitedProcs[0]->lxid;
+	}
+	Assert(nDeadlockDetails > 0);
+	local_wfg->nDeadlockInfo = info->nDeadlock_info;
+	local_wfg->deadlock_info = (DEADLOCK_INFO *)palloc(sizeof(DEADLOCK_INFO) * info->nDeadlock_info);
+	for (ii = 0; ii < info->nDeadlock_info; ii++)
+	{
+		memcpy(&local_wfg->deadlock_info[ii], &info->deadlock_info[ii], sizeof(DEADLOCK_INFO));
+	}
+	local_wfg->backend_activity = (char **)palloc0(sizeof(char *) * info->nDeadlock_info);
+	if (local_wfg->local_wfg_flag & WfG_HAS_EXTERNAL_LOCK)
+		local_wfg->external_lock = GetExternalLockProperties(&deadlockDetails[info->nDeadlock_info -1].locktag);
+	else
+		local_wfg->external_lock = NULL;
+
+	add_backend_activities_local_wfg(local_wfg);
+
+	return local_wfg;
+}
+
+
+
+/*
+ * We use database system id to identify a database instance.   This is created by initdb and does not change
+ * throughout the database lifetime.   This is essentially the timestan when initdb created the database
+ * materials plus process id of initdb.   We can assume this is unique enough throughout correction of
+ * databases in the scope.
+ *
+ * K.Suzuki: When database is cloned with pg_basebackup, cold copy or any similar way, database data directory
+ *           will be simply copied and we have a risk different database has the same database system id.
+ *           To avoid this, we will provide two ways to specify different identification method:
+ *           Offline utility to update database system identifier (pg_database_system_identifier), which
+ *           must run while the daabase is not active.
+ */
+uint64
+get_database_system_id(void)
+{
+	ControlFileData *controlfiledata;
+	bool			 crc_ok;
+
+	if (my_database_system_identifier)
+		return my_database_system_identifier;
+	controlfiledata = get_controlfile(DataDir, &crc_ok);
+	my_database_system_identifier = controlfiledata->system_identifier;
+	pfree(controlfiledata);
+	return my_database_system_identifier;
+}
+
+/*
+ * For test functions.
+ */
+const char *
+locktagTypeName(LockTagType type)
+{
+	switch(type)
+	{
+		case LOCKTAG_RELATION:
+			return "LOCKTAG_RELATION";
+		case LOCKTAG_RELATION_EXTEND:
+			return "LOCKTAG_RELATION_EXTEND";
+		case LOCKTAG_PAGE:
+			return "LOCKTAG_PAGE";
+		case LOCKTAG_TUPLE:
+			return "LOCKTAG_TUPLE";
+		case LOCKTAG_TRANSACTION:
+			return "LOCKTAG_TRANSACTION";
+		case LOCKTAG_VIRTUALTRANSACTION:
+			return "LOCKTAG_VIRTUALTRANSACTION";
+		case LOCKTAG_SPECULATIVE_TOKEN:
+			return "LOCKTAG_SPECULATIVE_TOKEN";
+		case LOCKTAG_OBJECT:
+			return "LOCKTAG_OBJECT";
+		case LOCKTAG_USERLOCK:
+			return "LOCKTAG_USERLOCK";
+		case LOCKTAG_EXTERNAL:
+			return "LOCKTAG_EXTERNAL";
+		case LOCKTAG_ADVISORY:
+			return "LOCKTAG_ADVISORY";
+	}
+	return "LOCKTAG_NO_SUCH_TYPE";
+}
+
+static GLOBAL_WFG *
+addToGlobalWfG(GLOBAL_WFG *global_wfg, LOCAL_WFG *local_wfg)
+{
+	Assert(data);
+
+	if (global_wfg == NULL)
+	{
+		global_wfg = (GLOBAL_WFG *)palloc(sizeof(GLOBAL_WFG));
+		global_wfg->nLocalWfg = 1;
+		global_wfg->local_wfg = (LOCAL_WFG **)palloc(sizeof(void *));
+		global_wfg->local_wfg[0] = local_wfg;
+	}
+	else
+	{
+		global_wfg->nLocalWfg++;
+		global_wfg->local_wfg = (LOCAL_WFG **)gdd_repalloc(global_wfg->local_wfg, sizeof(void *) * global_wfg->nLocalWfg);
+		global_wfg->local_wfg[global_wfg->nLocalWfg - 1] = local_wfg;
+	}
+	return global_wfg;
+}
+
+/*
+ * Entry point of global deadlock check.
+ *
+ * Called just after DeadLockCheck() from proc.c.
+ *
+ * Be aware that this function does not assume the caller has acquired lock line
+ * locks.   It is highly recommended to release all the lockline of LWLocks.
+ *
+ */
+DeadLockState
+GlobalDeadlockCheck(PGPROC *proc)
+{
+	return GlobalDeadlockCheck_int(proc, NULL, NULL);
+}
+
+/*
+ * This is the latter part of global deadlock check.
+ *
+ * At first, if a backend cannot acquire a LOCK within deadlock timeout, proc.c calls
+ * DeadLockCheck().   If DeadLockCheck() finds local deadlock starting at the backend,
+ * there are no difference from older version of DeadLockCheck().  Caller of DeadLockCheck()
+ * need to acqire LWLock for all the lock lines for LOCK objects.
+ *
+ * After then, DeadLockCheck() may return DS_DEADLOCK_INFO.   This is an addition to the
+ * return value.   When proc.c receives this return value, it suggests that wait-for-graph
+ * exntends to remote transaction.
+ *
+ * To check wait-for-graph expanding to remote transaction, the caller must call GlobalDeadlockCheck().
+ * Please note that the caller can release all the locklines.
+ *
+ * GlobalDeadlockCheck_int() is the bod of GLobalDeadlockCheck() called in the following wait-for-graph
+ * check at remote databases.
+ */
+static DeadLockState
+GlobalDeadlockCheck_int(PGPROC *proc, GLOBAL_WFG *global_wfg, RETURNED_WFG **rv)
+{
+	DeadLockState	 state;
+	int				 nWfG;
+	LOCAL_WFG		*local_wfg;
+	DEADLOCK_INFO_BUP	*curBup;
+	RETURNED_WFG	*returned_wfg = NULL;
+	RETURNED_WFG	*returning_wfg;
+	int				 ii;
+#ifdef GDD_DEBUG
+	StringInfoData	out;
+#endif /* GDD_DEBUG */
+
+	globalVisitedProcs = NULL;
+	nGlobalVisitedProcs = 0;
+	returning_wfg = NULL;
+
+#ifdef GDD_DEBUG
+	initStringInfo(&out);
+	appendStringInfo(&out, "\n=== %s, line: %d ================================================", __func__, __LINE__);
+	print_global_wfg(&out, global_wfg);
+	elog(DEBUG1, "%s", out.data);
+	resetStringInfo(&out);
+#endif /* GDD_DEBUG */
+	/*
+	 * Initialize .so for remote database WfG check
+	 */
+	if (pg_gdd_check_func == NULL)
+		load_file("libpqgddcheckremote", false);
+
+	/*
+	 * Previous DeadLockCheck() may have found more than one possible piece of wait-for-graph
+	 * spanning to remote transactions.
+	 *
+	 * We need to check all these possible wait-for-graph.
+	 */
+	for (curBup = deadlock_info_bup_head; curBup; curBup = curBup->next)
+	{
+		if (curBup->state == DS_HARD_DEADLOCK)
+			/*
+			 * This status should appear only in downstream databae, where this state has already
+			 * been handled in globalDeadlockCheckFromRemote().
+			 */
+			continue;
+		/*
+		 * Check if EXTERANL lock of current deadlock info is not in the global wfg
+		 */
+		if (external_lock_already_in_gwfg(global_wfg, curBup))
+			continue;
+		local_wfg = BuildLocalWfG(proc, curBup);
+#ifdef GDD_DEBUG
+		appendStringInfo(&out, "\n=== %s, line: %d ================================================", __func__, __LINE__);
+		print_local_wfg(&out, local_wfg, 0, 1);
+		elog(DEBUG1, "%s", out.data);
+		resetStringInfo(&out);
+#endif /* GDD_DEBUG */
+		if (!local_wfg || !check_local_wfg_is_stable(local_wfg))
+			continue;
+		nWfG = GlobalDeadlockCheckRemote(local_wfg, global_wfg, &returned_wfg);
+		if (nWfG == 0)
+			continue;
+		if (nWfG < 0)
+			elog(ERROR, "Error in remote wait-for-graph check.\n");
+		/*
+		 * Check of local wait-for-graph is stable
+		 */
+		if (!check_local_wfg_is_stable(local_wfg))
+		{
+			/* Checked WFG is not deadlock candidate. */
+			free_local_wfg(local_wfg);
+			continue;
+		}
+		if (deadlockCheckMode == DLCMODE_LOCAL)
+		{
+			/*
+			 * If we are at the beginning database (ORIGIN), we need to recheck if the observerd
+			 * wait-for-graph is static.   If not, it's not a part of a deadlock.
+			 *
+			 * Now nReturnedWfg is at most one.
+			 */
+			for (ii = 0; ii < returned_wfg->nReturnedWfg; ii++)
+			{
+				if (returned_wfg->state[ii] == DS_HARD_DEADLOCK || returned_wfg->state[ii] == DS_GLOBAL_ERROR)
+				{
+					if (returned_wfg->state[ii] == DS_HARD_DEADLOCK)
+					{
+						MemoryContext	oldctx;
+
+						oldctx = MemoryContextSwitchTo(CurTransactionContext);
+						global_deadlock_info = DeserializeGlobalWfG(returned_wfg->global_wfg_in_text[ii]);
+						MemoryContextSwitchTo(oldctx);
+					}
+					else
+						global_deadlock_info = NULL;
+					free_returned_wfg(returned_wfg);
+					state = returned_wfg->state[ii];
+					goto returning;
+				}
+			}
+		}
+		else
+			/*
+			 * If we are not at the begging database (ORIGIN), we return all the possible wait-for-graph
+			 * for candidate deadlock to upstream.
+			 */
+			returning_wfg = add_returned_wfg(returning_wfg, returned_wfg, true);
+	}
+	if (deadlockCheckMode == DLCMODE_LOCAL)
+		state = DS_NO_DEADLOCK;
+	else
+		state = returning_wfg ? DS_DEADLOCK_INFO : DS_NO_DEADLOCK;
+
+returning:
+
+	/*
+	 * Cleanup global deadlock check object local to this database
+	 */
+#ifdef GDD_DEBUG
+	pfree(out.data);
+#endif /* GDD_DEBUG */
+	if (globalVisitedProcs)
+		pfree(globalVisitedProcs);
+	nGlobalVisitedProcs = 0;
+	globalVisitedProcs = NULL;
+
+	if (globalVisitedExternalLock)
+		pfree(globalVisitedExternalLock);
+	nGlobalVisitedExternalLock = 0;
+	globalVisitedExternalLock = NULL;
+
+	clean_deadlock_info_bup();
+
+	if (rv)
+		*rv = returning_wfg;
+	return state;
+}
+
+/*
+ ********************************************************************************************
+ *
+ * K.Suzuki: Global deadlock detection part
+ *
+ ********************************************************************************************
+ */
+
+/*
+ * Called from GlobalDeadlockCheck_int() and takes care of checking wait-for-graph at
+ * downstream.
+ *
+ * If This is the start point to detect global deadlock, specify NULL to global_wfg.
+ * Otherwise, specify received global wfg as global_wfg.
+ *
+ * The caller must check that local_wfg is stable and it terminates with LOCKTAG_EXTERNAL
+ */
+#ifdef GDD_DEBUG
+int		gdd_debug_remote_pid;		/* For debug only */
+#endif /* GDD_DEBUG */
+
+#define	GDD_CHECK_BY_FUNC	true
+
+static int
+GlobalDeadlockCheckRemote(LOCAL_WFG *local_wfg, GLOBAL_WFG *global_wfg, RETURNED_WFG **returning_wfg)
+{
+	GLOBAL_WFG		*new_global_wfg;
+	char			*global_wfg_text = NULL;
+	StringInfoData	 cmd;
+	char			*dsn_downstream;
+
+	if (!(local_wfg->local_wfg_flag & WfG_HAS_EXTERNAL_LOCK))
+		return DS_NO_DEADLOCK;
+
+	initStringInfo(&cmd);
+	*returning_wfg = NULL;
+
+	dsn_downstream = local_wfg->external_lock->dsn;
+	new_global_wfg = copy_global_wfg(global_wfg);
+
+	/*
+	 * Build global wait-for-graph and translate to string to send to the downstream database.
+	 */
+	new_global_wfg = addToGlobalWfG(new_global_wfg, (void *)local_wfg);
+	global_wfg_text = SerializeGlobalWfG(new_global_wfg);
+
+	*returning_wfg = pg_gdd_check_func(dsn_downstream, global_wfg_text);
+
+	return (*returning_wfg)->nReturnedWfg;
+}
+
+/*
+ * Work function for pg_global_deadlock_check_from_remote() SQL function.
+ */
+static RETURNED_WFG *
+globalDeadlockCheckFromRemote(char *global_wfg_text, DeadLockState *state)
+{
+	GLOBAL_WFG 			*global_wfg;
+	PGPROC				*pgproc_in_passed_external_lock;
+	ExternalLockInfo	*passed_external_lock;			/* External lock passed from upstream */
+	RETURNED_WFG	 	*returning_global_wfg = NULL;	/* To be returned to the upstream */
+	RETURNED_WFG		*returned_wfg = NULL;			/* Returned from the downstream */
+	DEADLOCK_INFO_BUP	*curr_bup;
+
+	*state = DS_NO_DEADLOCK;
+
+	/*
+	 * Deserialize received Global WFG from upstream
+	 */
+	global_wfg = DeserializeGlobalWfG(global_wfg_text);
+	if (global_wfg == NULL)
+	{
+		*state = DS_GLOBAL_ERROR;
+		elog(WARNING, "The input parameter does not contain valid wait-for-graph data.");
+		goto returning;
+	}
+
+	/*
+	 * Determine deadlock check mode
+	 */
+	deadlockCheckMode = globalDeadlockCheckMode(global_wfg);
+	if (deadlockCheckMode == DLCMODE_ERROR)
+	{
+		*state = DS_GLOBAL_ERROR;
+		elog(WARNING, "The input parameter does not contain valid wait-for-graph data.");
+		goto returning;
+	}
+
+	/*
+	 * Passed_exernal_lock indicates EXTERNAL LOCK of direct upstream database, connecting to the current database.
+	 * This is used to check if the external lock is stable, the target PGPROC, pid and txn did not change.
+	 */
+	passed_external_lock = global_wfg->local_wfg[global_wfg->nLocalWfg - 1]->external_lock;
+
+	/*
+	 * Check if the direct upstream's external lock is stable
+	 */
+	pgproc_in_passed_external_lock = find_pgproc_pgprocno(passed_external_lock->target_pgprocno);
+
+	Lock_PgprocArray();
+	Lock_Pgproc(pgproc_in_passed_external_lock);
+	if (pgproc_in_passed_external_lock == NULL ||
+		pgproc_in_passed_external_lock->pid != passed_external_lock->target_pid ||
+		pgproc_in_passed_external_lock->pgprocno != passed_external_lock->target_pgprocno || /* K.Suzuki: maybe this is not needed */
+		pgproc_in_passed_external_lock->lxid != passed_external_lock->target_txn)
+	{
+		/*
+		 * Process or transaction status changed from EXTERNAL LOCK.   This WfG is not stable and is not
+		 * a part of a global deadlock.
+		 */
+		Unlock_Pgproc(pgproc_in_passed_external_lock);
+		Unlock_PgprocArray();
+		*state = DS_NO_DEADLOCK;
+		goto returning;
+	}
+	Unlock_Pgproc(pgproc_in_passed_external_lock);
+	Unlock_PgprocArray();
+
+	/*
+	 * Now the status is stable so far and this WfG may be a part of a global deadlock.
+	 */
+	/*
+	 * Check local deadlock.
+	 */
+	hold_all_lockline();
+	/*
+	 * Check of local wait-for-graph begging at the proc in the external lock.
+	 * Here, all the candidate wait-for-graph is stored in deadlock info backup
+	 * chain.
+	 */
+	*state = DeadLockCheck_int(pgproc_in_passed_external_lock);
+	release_all_lockline();
+
+	if (*state != DS_DEADLOCK_INFO)
+		/* Local state from this proc is "no deadlock" or "local deadlock". Nothing to do here. */
+		goto returning;
+
+	/*
+	 * Find if global deadlock is found in this database
+	 */
+	for (curr_bup = deadlock_info_bup_head; curr_bup; curr_bup = curr_bup->next)
+	{
+		LOCAL_WFG	*local_wfg;
+		GLOBAL_WFG	*global_wfg_here;
+
+		if (curr_bup->state == DS_HARD_DEADLOCK)
+		{
+			*state = DS_DEADLOCK_INFO;
+			local_wfg = BuildLocalWfG(NULL, curr_bup);
+
+			if (check_local_wfg_is_stable(local_wfg))
+			{
+				/*
+				 * Add local wait-for-graph in this database to the global wait-for-graph to be returned to
+				 * upstream database.
+				 */
+				/*
+				 * Add activity of each process involved in this wait-for-graph, using pgstat_get_backend_current_activity(pid, false)
+				 */
+				add_backend_activities_local_wfg(local_wfg);
+				global_wfg_here = addToGlobalWfG(global_wfg, local_wfg);
+				returning_global_wfg = addGlobalWfgToReturnedWfg(returning_global_wfg, curr_bup->state, global_wfg_here);
+				goto returning;
+			}
+			else
+			{
+				pfree(local_wfg);
+				continue;
+			}
+		}
+	}
+	/*
+	 * No global deadlock is found in this database.
+	 *
+	 * Then continue further global wait-for-graph search to other downstream databae.
+	 */
+	*state = GlobalDeadlockCheck_int(pgproc_in_passed_external_lock, global_wfg, &returned_wfg);
+	if (*state != DS_DEADLOCK_INFO)
+		goto returning;
+	returning_global_wfg = add_returned_wfg(returning_global_wfg, returned_wfg, true);
+returning:
+	if (returning_global_wfg)
+		*state = DS_DEADLOCK_INFO;
+	return returning_global_wfg;
+}
+
+/*
+ * Function name
+ *
+ *	SQL function name: pg_global_deadlock_check_from_remote(IN wfg text, OUT record)
+ *
+ *  This is called from global deadlock check worker function through libpq.
+ *
+ *  Return value is set of tuple: (dead_lock_state int, wfg text)
+ *  It started to return more than one tuple but at present, this returns just one
+ *  tuple.
+ */
+
+Datum
+pg_global_deadlock_check_from_remote(PG_FUNCTION_ARGS)
+{
+#define CHARLEN 16
+#define COLNUM	2
+	RETURNED_WFG	 	*returning_global_wfg;
+	DeadLockState		 state;
+
+
+	/* Used to return the result */
+	FuncCallContext	*funcctx;
+	TupleDesc		 tupdesc;
+	AttInMetadata	*attinmeta;
+	HeapTupleData	 tupleData;
+	HeapTuple		 tuple = &tupleData;
+	char			*values[COLNUM];
+	char			 state_for_tuple[CHARLEN];
+	int				 ii;
+
+	if (SRF_IS_FIRSTCALL())
+	{
+		MemoryContext	 oldcontext;
+		char			*global_wfg_text;
+
+		funcctx = SRF_FIRSTCALL_INIT();
+
+		/* Initialize itelating function */
+		oldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);
+		if (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)
+			ereport(ERROR,
+				(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
+				 errmsg("function returning record called in context "
+						"that cannot accept type record")));
+        attinmeta = TupleDescGetAttInMetadata(tupdesc);
+        funcctx->attinmeta = attinmeta;
+		global_wfg_text = PG_GETARG_CSTRING(0);
+
+		returning_global_wfg = globalDeadlockCheckFromRemote(global_wfg_text, &state);
+
+		funcctx->user_fctx = returning_global_wfg;
+		funcctx->max_calls = returning_global_wfg ? returning_global_wfg->nReturnedWfg : 0;
+
+		MemoryContextSwitchTo(oldcontext);
+	}
+	funcctx = SRF_PERCALL_SETUP();
+	values[0] = state_for_tuple;
+	if (funcctx->call_cntr < funcctx->max_calls)
+	{
+		Datum	result;
+
+		returning_global_wfg = funcctx->user_fctx;
+		attinmeta = funcctx->attinmeta;
+		ii = 0;
+		snprintf(values[ii++], CHARLEN, "%d", returning_global_wfg->state[funcctx->call_cntr]);
+		values[ii] = returning_global_wfg->global_wfg_in_text[funcctx->call_cntr];
+		tuple = BuildTupleFromCStrings(attinmeta, values);
+		result = HeapTupleGetDatum(tuple);
+		SRF_RETURN_NEXT(funcctx, result);
+	}
+	SRF_RETURN_DONE(funcctx);
+#undef CHARLEN
+#undef COLNUM
+}
+
+/*
+ * Function
+ *
+ * SQL function name: pg_global_deadlock_check_describe_backend(IN int, OUT record)
+ *
+ * Input parameter is pid of the downstream database transaction backend.
+ * Output tuple is (pid int, pgprocno int, lxid int)
+ *
+ * Application using global deadlock detection can issue this function
+ *
+ * Return value is one integer: DeadlockState
+ */
+Datum
+pg_global_deadlock_check_describe_backend(PG_FUNCTION_ARGS)
+{
+#define CHARLEN 32
+#define NCOLUMN 3
+	int32	 pgprocno;
+	int32	 lxid;
+	int32	 pid;
+	PGPROC	*proc;
+	int		 ii;
+
+	/* Used to return the result */
+	TupleDesc		 tupd;
+	HeapTupleData	 tupleData;
+	HeapTuple		 tuple = &tupleData;
+	char			*values[NCOLUMN];
+	char			 Values[NCOLUMN][CHARLEN];
+	Datum			 result;
+
+	pid = PG_GETARG_INT32(0);
+	Lock_PgprocArray();
+	if (pid < 0)
+		proc = MyProc;
+	else
+	{
+		proc = find_pgproc(pid);
+		if (proc == NULL)
+		{
+			Unlock_PgprocArray();
+			elog(ERROR, "Specified pid %d is not in backend.", pid);
+		}
+	}
+	pgprocno = proc->pgprocno;
+	lxid = proc->lxid;
+	Unlock_PgprocArray();
+
+	for (ii = 0; ii < NCOLUMN; ii++)
+		values[ii] = &Values[ii][0];
+	tupd = CreateTemplateTupleDesc(NCOLUMN);
+	ii = 1;
+	TupleDescInitEntry(tupd, ii++, "pid", INT4OID, -1, 0);
+	TupleDescInitEntry(tupd, ii++, "pgprocno", INT4OID, -1, 0);
+	TupleDescInitEntry(tupd, ii++, "lxid", NUMERICOID, -1, 0);
+	ii = 0;
+	snprintf(values[ii++], CHARLEN, "%d", pid);
+	snprintf(values[ii++], CHARLEN, "%d", pgprocno);
+	snprintf(values[ii++], CHARLEN, "%u", lxid);
+	tuple =  BuildTupleFromCStrings(TupleDescGetAttInMetadata(tupd), values);
+	result = TupleGetDatum(TupleDescGetSlot(tupd), tuple);
+
+	PG_RETURN_DATUM(result);
+
+#undef NCOLUMN
+#undef CHARLEN
+}
+	
+/*
+ * This check if external lock found in local database wait-for-graph is
+ * already in the global wait-for-graph.
+ *
+ * This works when DeadlockCheckMode is DLCMODE_GLOBAL_AGAIN or DLCMODE_GLOBAL_ORIGIN.
+ * In these modes, we should not check wait-for-graph beyond already-checked
+ * external lock.
+ */
+static bool
+external_lock_already_in_gwfg(GLOBAL_WFG *global_wfg, DEADLOCK_INFO_BUP *dl_info_bup)
+{
+	int			ii;
+	uint64		my_system_identifier;
+
+	if (global_wfg == NULL)
+		return false;
+
+	my_system_identifier = get_database_system_id();
+
+	if (dl_info_bup->state != DS_EXTERNAL_LOCK)
+		return false;
+	for (ii = 0; ii < global_wfg->nLocalWfg; ii++)
+	{
+		LOCAL_WFG			*local_wfg;
+		ExternalLockInfo	*external_lock;
+		DEADLOCK_INFO		*dl_info;
+		LOCKTAG				*dl_locktag;
+
+		local_wfg = (LOCAL_WFG *)(global_wfg->local_wfg[ii]);
+		if (local_wfg->database_system_identifier != my_system_identifier)
+			continue;
+		if (!(((LOCAL_WFG *)(global_wfg->local_wfg[ii]))->local_wfg_flag & WfG_HAS_EXTERNAL_LOCK))
+			continue;
+		external_lock = local_wfg->external_lock;
+		dl_info = &dl_info_bup->deadlock_info[dl_info_bup->nDeadlock_info - 1];
+		dl_locktag = &dl_info->locktag;
+		/* Check locktag against external lock in local wfg */
+		if (dl_locktag->locktag_field1 != external_lock->pgprocno)
+			continue;
+		if (dl_locktag->locktag_field2 != external_lock->pid)
+			continue;
+		if (dl_locktag->locktag_field3 != external_lock->txnid)
+			continue;
+		if (dl_locktag->locktag_field4 != external_lock->serno)
+			continue;
+		if (dl_locktag->locktag_type != LOCKTAG_EXTERNAL)
+			continue;
+		if (dl_locktag->locktag_lockmethodid != DEFAULT_LOCKMETHOD)
+			continue;
+		return true;
+	}
+	return false;
+}
+
+/*
+ * Acquire all the LWLocks for LOCK
+ */
+static void
+hold_all_lockline(void)
+{
+	int ii;
+
+	for (ii = 0; ii < NUM_LOCK_PARTITIONS; ii++)
+		LWLockAcquire(LockHashPartitionLockByIndex(ii), LW_EXCLUSIVE);
+}
+
+/*
+ * Release all the LWLocks for LOCK
+ */
+static void
+release_all_lockline(void)
+{
+	int	ii;
+
+	for (ii = 0; ii < NUM_LOCK_PARTITIONS; ii++)
+		LWLockRelease(LockHashPartitionLockByIndex(ii));
+}
+
+
+DEADLOCK_INFO *
+GetDeadLockInfo(int32 *nInfo)
+{
+	*nInfo = nDeadlockDetails;
+	return deadlockDetails;
+}
+
+/*
+ * Caller should acquire LWLock for ProcArrayLock.
+ */
+static PGPROC *
+find_pgproc(int pid)
+{
+    int ii;
+
+    for (ii = 0; ii < ProcGlobal->allProcCount; ii++)
+    {
+        if (ProcGlobal->allProcs[ii].pid == pid)
+        {
+            return &ProcGlobal->allProcs[ii];
+        }
+    }
+    return NULL;
+}
+
+/*
+ * Caller does not have to acquire LWLock for ProcArrayLock.
+ * To refer to the value of PGPROC found, the caller should acquire appropriate
+ * LWLock for ProcArrayLock.
+ */
+static PGPROC *
+find_pgproc_pgprocno(int pgprocno)
+{
+	if (pgprocno < 0)
+		return MyProc;
+	if (pgprocno >= ProcGlobal->allProcCount)
+		elog(ERROR, "Pgprocno is out of bounds. Max should be %d.", ProcGlobal->allProcCount);
+	return &ProcGlobal->allProcs[pgprocno];
+}
+
+/*
+ * Deadlock Info Backup code: For one scan, there could be more than one possible WfG path going
+ * remote.
+ *
+ * Information should be stored in currTransactionContext.
+ */
+static void
+backup_deadlock_info(DeadLockState state)
+{
+	DEADLOCK_INFO_BUP	*info;
+	MemoryContext		 oldctx;
+
+	oldctx = MemoryContextSwitchTo(CurTransactionContext);
+
+	info = (DEADLOCK_INFO_BUP *)palloc(sizeof(DEADLOCK_INFO_BUP) + sizeof(DEADLOCK_INFO) * nDeadlockDetails);
+	info->nDeadlock_info = nDeadlockDetails;
+	info->state = state;
+	info->next = NULL;
+	memcpy(&info->deadlock_info[0], deadlockDetails, sizeof(DEADLOCK_INFO) * nDeadlockDetails);
+	if (deadlock_info_bup_head == NULL)
+		deadlock_info_bup_head = deadlock_info_bup_tail = info;
+	else
+	{
+		deadlock_info_bup_tail->next = info;
+		deadlock_info_bup_tail = info;
+	}
+
+	MemoryContextSwitchTo(oldctx);
+}
+
+static void
+clean_deadlock_info_bup_recursive(DEADLOCK_INFO_BUP *info)
+{
+	if (info->next != NULL)
+		clean_deadlock_info_bup_recursive(info->next);
+	pfree(info);
+}
+
+static void
+clean_deadlock_info_bup(void)
+{
+	MemoryContext	oldctx;
+
+	if (deadlock_info_bup_head == NULL)
+		return;
+
+	oldctx = MemoryContextSwitchTo(CurTransactionContext);
+
+	clean_deadlock_info_bup_recursive(deadlock_info_bup_head);
+	deadlock_info_bup_head = deadlock_info_bup_tail = NULL;
+
+	MemoryContextSwitchTo(oldctx);
+}
+
+/*
+ * Check if wait-for-graph represents the current local status
+ *
+ * Local WFG must be for the instance the backend is running.
+ */
+static bool
+check_local_wfg_is_stable(LOCAL_WFG *localWfG)
+{
+	DEADLOCK_INFO	*info;
+	int				 nDeadlockInfo;
+	int				 ii;
+	PGPROC			*proc;
+
+	Assert(localWfG != NULL);
+
+	info = localWfG->deadlock_info;
+	nDeadlockInfo = localWfG->nDeadlockInfo;
+	Lock_PgprocArray();
+
+	for (ii = 0; ii < nDeadlockInfo; ii++)
+	{
+		proc = find_pgproc_pgprocno(info[ii].pgprocno);
+		if (proc == NULL)
+			goto instable;			/* No PGPROC found */
+
+		Lock_Pgproc(proc);
+		if ((proc->pid != info[ii].pid) ||
+			(proc->waitLockMode != info[ii].lockmode) ||
+			(memcmp(&(proc->waitLock->tag), &info[ii].locktag, sizeof(LOCKTAG))) ||
+			(proc->lxid != info[ii].txid))
+		{
+			/*
+			 * One of the following condition applies
+			 * - PGPROC is running different process
+			 * - PGPROC is waiting with different lock mode
+			 * - PGPROC is waiting for different LOCK
+			 * - PGPROC is running different TXN
+			 */
+			Unlock_Pgproc(proc);
+			goto instable;
+		}
+		Unlock_Pgproc(proc);
+	}
+	Unlock_PgprocArray();
+	return true;
+
+instable:
+	Unlock_PgprocArray();
+	return false;
+}
+
+/*
+ * Add new returne_wfg member to specified returned_wfg
+ */
+static RETURNED_WFG *
+add_returned_wfg(RETURNED_WFG *dest, RETURNED_WFG *src, bool clean_opt)
+{
+	int		ii, jj;
+	int		old_num;
+	int		new_num;
+
+	if ((src == NULL) || (src->nReturnedWfg == 0))
+		return dest;
+	if (dest == NULL)
+		dest = palloc0(sizeof(RETURNED_WFG));
+	old_num = dest->nReturnedWfg;
+	new_num = old_num + src->nReturnedWfg;
+
+	dest->state = (DeadLockState *)gdd_repalloc(dest->state, sizeof(DeadLockState) * new_num);
+	dest->global_wfg_in_text = (char **)gdd_repalloc(dest->global_wfg_in_text, sizeof(char *) * new_num);
+	for (ii = old_num, jj = 0; ii < new_num; ii++, jj++)
+	{
+		dest->state[ii] = src->state[jj];
+		dest->global_wfg_in_text[ii] = pstrdup(src->global_wfg_in_text[jj]);
+	}
+	dest->nReturnedWfg = new_num;
+	if (clean_opt)
+		free_returned_wfg(src);
+	return dest;
+}
+
+/*
+ * Add new global wfg to specified returned wfg
+ */
+static RETURNED_WFG *
+addGlobalWfgToReturnedWfg(RETURNED_WFG *returned_wfg, DeadLockState state, GLOBAL_WFG *global_wfg)
+{
+	char			*global_wfg_txt;
+
+	if (returned_wfg == NULL)
+		returned_wfg = palloc0(sizeof(RETURNED_WFG));
+	global_wfg_txt = SerializeGlobalWfG(global_wfg);
+	returned_wfg->nReturnedWfg++;
+	returned_wfg->state = gdd_repalloc(returned_wfg->state, sizeof(DeadLockState) * returned_wfg->nReturnedWfg);
+	returned_wfg->state[returned_wfg->nReturnedWfg - 1] = state;
+	returned_wfg->global_wfg_in_text = gdd_repalloc(returned_wfg->global_wfg_in_text, sizeof(char *) * returned_wfg->nReturnedWfg);
+	returned_wfg->global_wfg_in_text[returned_wfg->nReturnedWfg - 1] = global_wfg_txt;
+	return returned_wfg;
+}
+
+
+/*
+ * Determine the mode of global deadlock check and extract self node's local wait-for-graph and add backend informaton
+ * to visited proc.
+ *
+ * This mode affects the behavior of DeadLockCheck().
+ */
+static DeadlockCheckMode
+globalDeadlockCheckMode(GLOBAL_WFG *global_wfg)
+{
+	uint64	my_database_system_id;
+	int		ii;
+	DeadlockCheckMode	rv = DLCMODE_LOCAL;
+
+	my_database_system_id = get_database_system_id();
+	globalVisitedProcs = NULL;
+	nGlobalVisitedProcs = 0;
+
+	globalVisitedExternalLock = NULL;
+	nGlobalVisitedExternalLock = 0;
+
+	visitedOriginPid = -1;
+	visitedOriginPgprocno = -1;
+	visitedOriginTxid = 0;
+
+	if (global_wfg == NULL)
+		return DLCMODE_LOCAL;
+	if (global_wfg->nLocalWfg <= 0 )
+	{
+		elog(WARNING, "The first or last local wait-for-graph was not compatible and could not deserialize.");
+		return DLCMODE_ERROR;
+	}
+	rv = DLCMODE_GLOBAL_NEW;
+	for (ii = 0; ii < global_wfg->nLocalWfg; ii++)
+	{
+		LOCAL_WFG *local_wfg;
+
+		local_wfg = (LOCAL_WFG *)global_wfg->local_wfg[ii];
+		if (local_wfg->database_system_identifier != my_database_system_id)
+			continue;
+		if (!(local_wfg->local_wfg_flag & WfG_HAS_EXTERNAL_LOCK))
+		{
+			nGlobalVisitedProcs = 0;
+			if (globalVisitedProcs)
+				pfree(globalVisitedProcs);
+			nGlobalVisitedExternalLock = 0;
+			if (globalVisitedExternalLock)
+				pfree(globalVisitedExternalLock);
+			elog(WARNING, "Some of local wait-for-graph does not terminate with external lock.");
+			return DLCMODE_ERROR;
+		}
+		if (ii == 0)
+		{
+			DEADLOCK_INFO	*info;
+			PGPROC	*proc_wk;
+
+			info = &local_wfg->deadlock_info[0];
+			proc_wk = find_pgproc_pgprocno(info->pgprocno);
+			if (proc_wk == NULL || proc_wk->pid != info->pid || proc_wk->lxid != info->txid)
+				continue;
+
+			nGlobalVisitedProcs++;
+			globalVisitedProcs = (PGPROC **)gdd_repalloc(globalVisitedProcs, sizeof(PGPROC *) * nGlobalVisitedProcs);
+			globalVisitedProcs[nGlobalVisitedProcs - 1] = proc_wk;
+
+			visitedOriginPid = local_wfg->visitedProcPid;
+			visitedOriginPgprocno = local_wfg->visitedProcPgprocno;
+			visitedOriginTxid = local_wfg->visitedProcLxid;
+
+			rv = DLCMODE_GLOBAL_ORIGIN;
+		}
+		else if (rv == DLCMODE_GLOBAL_NEW)
+			rv = DLCMODE_GLOBAL_AGAIN;
+		/* Setup EXTERNAL LOCK going out from this node in the global wfg */
+		nGlobalVisitedExternalLock++;
+		globalVisitedExternalLock
+			= (ExternalLockInfo **)gdd_repalloc(globalVisitedExternalLock,
+										   sizeof(ExternalLockInfo *) * nGlobalVisitedExternalLock);
+		globalVisitedExternalLock[nGlobalVisitedExternalLock -1] = local_wfg->external_lock;
+	}
+	return rv;
+}
+
+static void
+free_local_wfg(LOCAL_WFG *local_wfg)
+{
+	if (!local_wfg)
+		return;
+	if (local_wfg->backend_activity)
+	{
+		int	ii;
+
+		for (ii = 0; ii < local_wfg->nDeadlockInfo; ii++)
+		{
+			if (local_wfg->backend_activity[ii])
+				pfree(local_wfg->backend_activity[ii]);
+		}
+		pfree(local_wfg->backend_activity);
+	}
+	if (local_wfg->deadlock_info)
+		pfree(local_wfg->deadlock_info);
+	if (local_wfg->external_lock)
+	{
+		if (local_wfg->external_lock->dsn)
+			pfree(local_wfg->external_lock->dsn);
+		pfree(local_wfg->external_lock);
+	}
+	pfree(local_wfg);
+}
+
+#ifdef GDD_DEBUG
+void
+free_global_wfg(GLOBAL_WFG *global_wfg)
+{
+	int ii;
+
+	if (!global_wfg)
+		return;
+	for (ii = 0; ii < global_wfg->nLocalWfg; ii++)
+		free_local_wfg(global_wfg->local_wfg[ii]);
+	pfree(global_wfg->local_wfg);
+	pfree(global_wfg);
+}
+#endif
+
+static void
+add_backend_activities_local_wfg(LOCAL_WFG *local_wfg)
+{
+	int	ii;
+	
+	for (ii = 0; ii < local_wfg->nDeadlockInfo; ii++)
+		local_wfg->backend_activity[ii] = pstrdup(pgstat_get_backend_current_activity(local_wfg->deadlock_info[ii].pid, false));
+}
+
+static void
+free_returned_wfg(RETURNED_WFG *r_wfg)
+{
+	int	ii;
+
+	if (r_wfg == NULL)
+		return;
+	if (r_wfg->state)
+		pfree(r_wfg->state);
+	if (r_wfg->global_wfg_in_text)
+	{
+		for (ii = 0; ii < r_wfg->nReturnedWfg; ii++)
+		{
+			if (r_wfg->global_wfg_in_text[ii])
+				pfree(r_wfg->global_wfg_in_text[ii]);
+		}
+		pfree(r_wfg->global_wfg_in_text);
+	}
+	pfree(r_wfg);
+}
+
+static LOCAL_WFG *
+copy_local_wfg(LOCAL_WFG *l_wfg)
+{
+	LOCAL_WFG	*copied;
+	int	ii;
+
+	copied = (LOCAL_WFG *)palloc(sizeof(LOCAL_WFG));
+	memcpy(copied, l_wfg, sizeof(LOCAL_WFG));
+	copied->deadlock_info = (DEADLOCK_INFO *)palloc(sizeof(DEADLOCK_INFO) * l_wfg->nDeadlockInfo);
+	memcpy(copied->deadlock_info, l_wfg->deadlock_info, sizeof(DEADLOCK_INFO) * l_wfg->nDeadlockInfo);
+	copied->external_lock = (ExternalLockInfo *)palloc(sizeof(ExternalLockInfo));
+	memcpy(copied->external_lock, l_wfg->external_lock, sizeof(ExternalLockInfo));
+	copied->external_lock->dsn = pstrdup(l_wfg->external_lock->dsn);
+	copied->backend_activity = (char **)palloc0(sizeof(char *) * l_wfg->nDeadlockInfo);
+	for (ii = 0; ii < l_wfg->nDeadlockInfo; ii++)
+	{
+		if (l_wfg->backend_activity[ii])
+			copied->backend_activity[ii] = pstrdup(l_wfg->backend_activity[ii]);
+	}
+	return copied;
+}
+
+static GLOBAL_WFG *
+copy_global_wfg(GLOBAL_WFG *g_wfg)
+{
+	GLOBAL_WFG	*copied;
+	int			 ii;
+
+	if (g_wfg == NULL)
+		return NULL;
+
+	copied = (GLOBAL_WFG *)palloc(sizeof(GLOBAL_WFG));
+
+	copied->nLocalWfg = g_wfg->nLocalWfg;
+	copied->local_wfg = (LOCAL_WFG **)palloc(sizeof(LOCAL_WFG *) * g_wfg->nLocalWfg);
+	for (ii = 0; ii < g_wfg->nLocalWfg; ii++)
+		copied->local_wfg[ii] = copy_local_wfg((g_wfg->local_wfg[ii]));
+	return copied;
+}
+
+#ifdef GDD_DEBUG
+static void
+print_global_wfg(StringInfo out, GLOBAL_WFG *g_wfg)
+{
+	int 	 ii;
+	int		 arraymax;
+
+	appendStringInfo(out, "\n**** STARTING GLOBAL_WFG %016lx ***************************", (uint64)g_wfg);
+	if (g_wfg == NULL)
+	{
+		appendStringInfo(out, "\nNo global wait-for-graph.");
+		return;
+	}
+	appendStringInfo(out, "\nnLocalWfg: %d", g_wfg->nLocalWfg);
+	if (g_wfg->nLocalWfg > GDD_ARRAY_MAX)
+	{
+		appendStringInfo(out, "\n** nLocalWfg: %d exceeds max value for debug. Printing only first %d **",
+				g_wfg->nLocalWfg, GDD_ARRAY_MAX);
+		arraymax = GDD_ARRAY_MAX;
+	}
+	else
+		arraymax = g_wfg->nLocalWfg;
+	for (ii = 0; ii < arraymax; ii++)
+	{
+		appendStringInfo(out, "\nlocal_wfg[%d] **********", ii);
+		print_local_wfg(out, g_wfg->local_wfg[ii], ii, g_wfg->nLocalWfg);
+	}
+	appendStringInfo(out, "**** END OF GLOBAL_WFG %016lx ***********************\n", (uint64)g_wfg);
+}
+
+static void
+print_local_wfg(StringInfo out, LOCAL_WFG *l_wfg, int idx, int total)
+{
+	int ii;
+	int	arraymax;
+
+	appendStringInfo(out, "\n**** STARTING LOCAL_WFG %016lx idx: %d/%d ******************",
+			   (uint64)l_wfg, idx, total);
+	appendStringInfo(out, "\nmagic: 0x%08x, flag: 0x%08x, database_syste_identifier: 0x%016lx",
+			   WfG_LOCAL_MAGIC, l_wfg->local_wfg_flag, l_wfg->database_system_identifier);
+	appendStringInfo(out, "\nvisitedProcPid: %d, visitedProcPgorocni: %d, visitedProcLxid: %u",
+			   l_wfg->visitedProcPid, l_wfg->visitedProcPgprocno, l_wfg->visitedProcLxid);
+	appendStringInfo(out, "\nnDeadlockInfo: %d", l_wfg->nDeadlockInfo);
+	if (l_wfg->nDeadlockInfo > GDD_ARRAY_MAX)
+	{
+		appendStringInfo(out, "\n** nDeadlockInfo: %d exceeds max value for debug. Printing only first %d **",
+				   l_wfg->nDeadlockInfo, GDD_ARRAY_MAX);
+		arraymax = GDD_ARRAY_MAX;
+	}
+	else
+		arraymax = l_wfg->nDeadlockInfo;
+
+	for (ii = 0; ii < arraymax; ii++)
+		print_deadlock_info(out, &(l_wfg->deadlock_info[ii]), ii, l_wfg->nDeadlockInfo);
+	if (l_wfg->local_wfg_flag & WfG_HAS_EXTERNAL_LOCK)
+		print_external_lock_info(out, l_wfg->external_lock);
+	else
+		appendStringInfo(out, "\n====== EXTERNAL_LOCK: NULL: Not set ========");
+	appendStringInfo(out, "\n**** END OF LOCAL_WFG %016lx idx: %d ******************", (uint64)l_wfg, idx);
+}
+
+static void
+print_external_lock_info(StringInfo out, ExternalLockInfo *e)
+{
+	appendStringInfo(out, "====== EXTERNAL_LOCK: %016ld: Not set ========\n", (uint64)e);
+	appendStringInfo(out, "pid: %d, pgprocno: %d, txnid: %u, serno: %d,\n", e->pid, e->pgprocno, e->txnid, e->serno);
+	appendStringInfo(out, "dsn: '%s'\n", e->dsn);
+	appendStringInfo(out, "target_pid: %d, target_pgprocno: %d, target_txn: %u\n", e->target_pid, e->target_pgprocno, e->target_txn);
+}
+
+
+static void
+print_deadlock_info(StringInfo out, DEADLOCK_INFO *info, int idx, int total)
+{
+	appendStringInfo(out, "---- STARTING DEADLOCK_INFO %016lx idx: %d/%d ------------------\n",
+			   		 (uint64)info, idx, total);
+	appendStringInfo(out, "LOCKTAG: field1: %d, field2: %d, field3: %d, field4: %d, type: %d (%s), methodid: %d\n",
+			   		 info->locktag.locktag_field1,
+			   		 info->locktag.locktag_field2,
+			   		 info->locktag.locktag_field3,
+			   		 info->locktag.locktag_field4,
+			   		 info->locktag.locktag_type,
+			   		 locktagTypeName(info->locktag.locktag_type),
+			   		 info->locktag.locktag_lockmethodid);
+	appendStringInfo(out, "lockmode: %d (%s), pid: %d, pgprocno: %d, txid: %d\n",
+			   		 info->lockmode,
+			   		 GetLockmodeName(info->locktag.locktag_lockmethodid, info->lockmode),
+			   		 info->pid,
+			   		 info->pgprocno,
+			   		 info->txid);
+}
+#endif /* GDD_DEBUG */
+
+
+/*
+ * Serialize/Deserialize global/local wait-for-graph
+ */
+
+static char *
+getAtoInt32(char *buf, int32 *value)
+{
+	int64 value64;
+
+	buf = getAtoInt64(buf, &value64);
+	*value = (int32)value64;
+	return buf;
+}
+
+static char *
+getAtoInt64(char *buf, int64 *value)
+{
+	long	v;
+
+	if (!buf)
+	{
+		*value = 0;
+		return NULL;
+	}
+	while (*buf < '0' || *buf > '9')
+	{
+		if (*buf == '-')
+		{
+			buf = getAtoInt64(buf + 1, value);
+			*value *= -1;
+			return buf;
+		}
+		buf++;
+	}
+	if (*buf == 0)
+	{
+		*value = 0;
+		return NULL;
+	}
+	v = 0;
+	while (*buf)
+	{
+		int ii;
+
+		if (*buf >= '0' && *buf <= '9')
+			ii = *buf - '0';
+		else
+		{
+			*value = v;
+			return buf;
+		}
+		v *= 10;
+		v += ii;
+		buf++;
+	}
+	*value = v;
+	return NULL;
+}
+
+static char *
+getAtoUint32(char *buf, uint32 *value)
+{
+	uint64 value64;
+
+	buf = getAtoUint64(buf, &value64);
+	*value = (uint32)value64;
+	return buf;
+}
+
+static char *
+getAtoUint16(char *buf, uint16 *value)
+{
+	uint64 value64;
+
+	buf = getAtoUint64(buf, &value64);
+	*value = (uint16)value64;
+	return buf;
+}
+
+static char *
+getAtoUint8(char *buf, uint8 *value)
+{
+	uint64 value64;
+
+	buf = getAtoUint64(buf, &value64);
+	*value = (uint8)value64;
+	return buf;
+}
+
+static char *
+getAtoUint64(char *buf, uint64 *value)
+{
+	uint64	v;
+
+	if (!buf)
+	{
+		*value = 0;
+		return NULL;
+	}
+	while (*buf < '0' || *buf > '9')
+		buf++;
+	if (*buf == 0)
+	{
+		*value = 0;
+		return NULL;
+	}
+	v = 0;
+	while (*buf)
+	{
+		int ii;
+
+		if (*buf >= '0' && *buf <= '9')
+			ii = *buf - '0';
+		else
+		{
+			*value = v;
+			return buf;
+		}
+		v *= 10;
+		v += ii;
+		buf++;
+	}
+	*value = v;
+	return NULL;
+}
+
+static char *
+getHexaToInt(char *buf, int *value)
+{
+	int	v;
+
+	if (!buf)
+	{
+		*value = 0;
+		return NULL;
+	}
+	while ((*buf < '0' || (*buf > '9' && *buf < 'A') || (*buf > 'F' && *buf < 'a') || (*buf > 'f')))
+		buf++;
+	if (*buf == 0)
+	{
+		*value = 0;
+		return NULL;
+	}
+	v = 0;
+	while (*buf)
+	{
+		int ii;
+
+		if (*buf >= '0' && *buf <= '9')
+			ii = *buf - '0';
+		else if (*buf >= 'A' && *buf <= 'F')
+			ii = *buf - 'A' + 10;
+		else if (*buf >= 'a' && *buf <= 'f')
+			ii = *buf - 'a' + 10;
+		else
+		{
+			*value = v;
+			return buf;
+		}
+		v = v << 4;
+		v += ii;
+		buf++;
+	}
+	*value = v;
+	return NULL;
+}
+
+static char *
+getHexaToLong(char *buf, long *value)
+{
+	long	v;
+
+	if (!buf)
+	{
+		*value = 0;
+		return NULL;
+	}
+	while ((*buf < '0' || (*buf > '9' && *buf < 'A') || (*buf > 'F' && *buf < 'a') || (*buf > 'f')))
+		buf++;
+	if (*buf == 0)
+	{
+		*value = 0;
+		return NULL;
+	}
+	v = 0;
+	while (*buf)
+	{
+		int ii;
+
+		if (*buf >= '0' && *buf <= '9')
+			ii = *buf - '0';
+		else if (*buf >= 'A' && *buf <= 'F')
+			ii = *buf - 'A' + 10;
+		else if (*buf >= 'a' && *buf <= 'f')
+			ii = *buf - 'a' + 10;
+		else
+		{
+			*value = v;
+			return buf;
+		}
+		v = v << 4;
+		v += ii;
+		buf++;
+	}
+	*value = v;
+	return NULL;
+}
+
+static char *
+getString(char *buf, char **value)
+{
+	StringInfoData v;
+
+	initStringInfo(&v);
+	while (*buf && *buf != '\'')
+		buf++;
+	if (!*buf)
+	{
+		*value = NULL;
+		return NULL;
+	}
+	buf++;
+	while(*buf)
+	{
+		if (*buf == '\'')
+		{
+			if (*(buf + 1) == '\'')
+			{
+				appendStringInfoChar(&v, *buf);
+				buf += 2;
+			}
+			else
+			{
+				*value = v.data;
+				return buf + 1;
+			}
+		}
+		else
+		{
+			appendStringInfoChar(&v, *buf);
+			buf++;
+		}
+	}
+	/* No trainig quote found! Invalid format. */
+	pfree(v.data);
+	*value = NULL;
+	return NULL;
+}
+
+static char *
+findChar(char *buf, char c)
+{
+	while(*buf && *buf != c)
+		buf++;
+	if (!*buf)
+		return NULL;
+	return buf + 1;
+}
+
+static bool
+CloseScan(char *buf)
+{
+	while(*buf == ' ' || *buf == '\t' || *buf == '\n')
+		buf++;
+	return *buf ? false : true;
+}
+
+static char *
+normalizeString(char *buf)
+{
+	StringInfoData v;
+
+	initStringInfo(&v);
+	if (buf == NULL)
+	{
+		appendStringInfoString(&v, "''");
+		return v.data;
+	}
+	appendStringInfoChar(&v, '\'');
+	while(*buf)
+	{
+		if (*buf == '\'')
+			appendStringInfoString(&v, "''");
+		else
+			appendStringInfoChar(&v, *buf);
+		buf++;
+	}
+	appendStringInfoChar(&v, '\'');
+	return v.data;
+}
+
+static char *
+SerializeLocalWfG(LOCAL_WFG *local_wfg)
+{
+	StringInfoData	s;
+	int				ii;
+
+	initStringInfo(&s);
+	/* Start */
+	appendStringInfoString(&s, "( ");
+	/* Magic */
+	appendStringInfo(&s, "%08x %016lx %08x ",
+			WfG_LOCAL_MAGIC,						/* Magic */
+			local_wfg->database_system_identifier,	/* Daabase system id */
+			local_wfg->local_wfg_flag);				/* Flag */
+
+	/* Visited Proc */
+	if (local_wfg->local_wfg_flag & WfG_HAS_VISITED_PROC)
+		appendStringInfo(&s, "( %d %d %d ) ",
+				local_wfg->visitedProcPid,
+				local_wfg->visitedProcPgprocno,
+				local_wfg->visitedProcLxid);
+
+	/* Deadlock Info */
+	/* 		Opening Paren  and nDedalockInfo */
+	appendStringInfo(&s, "( %d ", local_wfg->nDeadlockInfo);
+
+	/* Each deadlock info */
+	for (ii = 0; ii < local_wfg->nDeadlockInfo; ii++)
+	{
+		DEADLOCK_INFO	*info = &(local_wfg->deadlock_info[ii]);
+		appendStringInfo(&s, "( ( %d %d %d %d %d %d ) %d %d %d %d ) ",
+				info->locktag.locktag_field1,		/* Locktag */
+				info->locktag.locktag_field2,
+				info->locktag.locktag_field3,
+				info->locktag.locktag_field4,
+				info->locktag.locktag_type,
+				info->locktag.locktag_lockmethodid,
+				info->lockmode,						/* lockmode, pid, pgprocno, txid */
+				info->pid,
+				info->pgprocno,
+				info->txid);
+	}
+	/* Closing */
+	appendStringInfoString(&s, ") ");
+
+	/* Backend activities */
+	/* Opening */
+	appendStringInfoString(&s, "( ");
+	for (ii = 0; ii < local_wfg->nDeadlockInfo; ii++)
+		appendStringInfo(&s, " %s",
+				normalizeString(local_wfg->backend_activity[ii]));
+	/* Closing */
+	appendStringInfoString(&s, " ) ");
+
+	/* External Lock Info */
+	if (local_wfg->local_wfg_flag & WfG_HAS_EXTERNAL_LOCK)
+	{
+		appendStringInfo(&s, "( %d %d %d %d %s %d %d %d )",
+				local_wfg->external_lock->pid,
+				local_wfg->external_lock->pgprocno,
+				local_wfg->external_lock->txnid,
+				local_wfg->external_lock->serno,
+				normalizeString(local_wfg->external_lock->dsn),
+				local_wfg->external_lock->target_pid,
+				local_wfg->external_lock->target_pgprocno,
+				local_wfg->external_lock->target_txn);
+	}
+	/* Closing */
+	appendStringInfoString(&s, " )");
+	return s.data;
+}
+
+
+static char *
+DeserializeLocalWfG(char *buf, LOCAL_WFG **local_wfg)
+{
+	LOCAL_WFG	*l_wfg = (LOCAL_WFG *)palloc0(sizeof(LOCAL_WFG));
+	int			 ii;
+	int32		 magic;
+
+	*local_wfg = NULL;
+	FindChar(buf, '(');
+	GetHexaToInt(buf, &magic);				/* Magic */
+	if (magic != WfG_LOCAL_MAGIC)
+		elog(ERROR, "Invalid Magic Number in serialized local wait-for-graph.");
+	GetHexaToLong(buf, &l_wfg->database_system_identifier);	/* System ID */
+	GetHexaToInt(buf, &l_wfg->local_wfg_flag);				/* Flag */
+	if (l_wfg->local_wfg_flag & WfG_HAS_VISITED_PROC)
+	{
+		/* Visited Proc Info */
+		FindChar(buf, '(');
+		GetAtoInt32(buf, &l_wfg->visitedProcPid);
+		GetAtoInt32(buf, &l_wfg->visitedProcPgprocno);
+		GetAtoInt32(buf, &l_wfg->visitedProcLxid);
+		FindChar(buf, ')');
+	}
+	/* Deadlock Info */
+	FindChar(buf, '(');
+	GetAtoInt32(buf, &l_wfg->nDeadlockInfo);
+	if (l_wfg->nDeadlockInfo <= 0)
+		elog(ERROR, "Invalid number of deadlock info in serialized wait-for-graph.");
+	l_wfg->deadlock_info = (DEADLOCK_INFO *)palloc(sizeof(DEADLOCK_INFO) * l_wfg->nDeadlockInfo);
+	for (ii = 0; ii < l_wfg->nDeadlockInfo; ii++)
+	{
+		DEADLOCK_INFO	*info = &(l_wfg->deadlock_info[ii]);
+		FindChar(buf, '(');
+		/* LOCKTAG */
+		FindChar(buf, '(');
+		GetAtoUint32(buf, &(info->locktag.locktag_field1));
+		GetAtoUint32(buf, &(info->locktag.locktag_field2));
+		GetAtoUint32(buf, &(info->locktag.locktag_field3));
+		GetAtoUint16(buf, &(info->locktag.locktag_field4));
+		GetAtoUint8(buf, &(info->locktag.locktag_type));
+		GetAtoUint8(buf, &(info->locktag.locktag_lockmethodid));
+		FindChar(buf, ')');
+		/* Others */
+		GetAtoInt32(buf, &(info->lockmode));
+		GetAtoInt32(buf, &(info->pid));
+		GetAtoInt32(buf, &(info->pgprocno));
+		GetAtoUint32(buf, &(info->txid));
+		FindChar(buf, ')');
+	}
+	FindChar(buf, ')');
+
+	/* Backend Activities */
+	FindChar(buf, '(');
+	l_wfg->backend_activity = (char **)palloc(sizeof(char *) * l_wfg->nDeadlockInfo);
+	for (ii = 0; ii < l_wfg->nDeadlockInfo; ii++)
+		GetString(buf, &l_wfg->backend_activity[ii]);
+	FindChar(buf, ')');
+
+	/* ExternalLock */
+	if (l_wfg->local_wfg_flag & WfG_HAS_EXTERNAL_LOCK)
+	{
+		ExternalLockInfo *e_lock;
+
+		e_lock = l_wfg->external_lock = (ExternalLockInfo *)palloc(sizeof(ExternalLockInfo));
+		FindChar(buf, '(');
+		GetAtoInt32(buf, &e_lock->pid);
+		GetAtoInt32(buf, &e_lock->pgprocno);
+		GetAtoUint32(buf, &e_lock->txnid);
+		GetAtoInt32(buf, &e_lock->serno);
+		GetString(buf, &e_lock->dsn);
+		GetAtoInt32(buf, &e_lock->target_pid);
+		GetAtoInt32(buf, &e_lock->target_pgprocno);
+		GetAtoUint32(buf, &e_lock->target_txn);
+		FindChar(buf, ')');
+	}
+	FindChar(buf, ')');
+	*local_wfg = l_wfg;
+	return buf;
+}
+
+static char *
+SerializeGlobalWfG(GLOBAL_WFG *g_wfg)
+{
+	StringInfoData	s;
+	int				ii;
+
+	initStringInfo(&s);
+
+	/* Start, open paren */
+	appendStringInfoString(&s, "( ");
+	appendStringInfo(&s, "%08x ", WfG_GLOBAL_MAGIC);
+
+	/* Local WfG */
+	appendStringInfo(&s, "( %d ", g_wfg->nLocalWfg);
+
+	for (ii = 0; ii < g_wfg->nLocalWfg; ii++)
+	{
+		char	*l_wfg;
+
+		/* Local Wfg in LOCAL_WFG */
+		l_wfg = SerializeLocalWfG((LOCAL_WFG *)(g_wfg->local_wfg[ii]));
+		appendStringInfoString(&s, l_wfg);
+		pfree(l_wfg);
+	}
+
+	/* Closing Local WfG */
+	appendStringInfoString(&s, " )");
+
+	/* Closing Global WfG */
+
+	appendStringInfoString(&s, " )");
+
+	return s.data;
+}
+
+static GLOBAL_WFG *
+DeserializeGlobalWfG(char *buf)
+{
+	GLOBAL_WFG	*g_wfg;
+	int			 ii;
+	int32		 magic;
+
+	g_wfg = (GLOBAL_WFG *)palloc(sizeof(GLOBAL_WFG));
+	FindChar(buf, '(');
+	GetHexaToInt(buf, &magic);
+	if (magic != WfG_GLOBAL_MAGIC)
+		elog(ERROR, "Invalid MAGIC in global wait-for-graph.");
+	FindChar(buf, '(');
+	GetAtoInt32(buf, &g_wfg->nLocalWfg);
+	if (g_wfg->nLocalWfg <= 0)
+		elog(ERROR, "Negative local wait-for-graph in the global wait-for-graph.");
+	g_wfg->local_wfg = (LOCAL_WFG **)palloc(sizeof(LOCAL_WFG *) * g_wfg->nLocalWfg);
+	
+	for (ii = 0; ii < g_wfg->nLocalWfg; ii++)
+	{
+		LOCAL_WFG	*l_wfg;
+		buf = DeserializeLocalWfG(buf, &l_wfg);
+		if (buf == NULL)
+			elog(ERROR, "Inconsistent serialized global wait-for-graph.");
+		g_wfg->local_wfg[ii] = l_wfg;
+	}
+	FindChar(buf, ')');
+	FindChar(buf, ')');
+	if (!CloseScan(buf))
+		return NULL;
+	return g_wfg;
+}
+
+static void
+GlobalDeadlockReport_int(void)
+{
+	StringInfoData	 clientbuf;	/* errdetail for client */
+	StringInfoData	 logbuf;	/* errdetail for server log */
+	StringInfoData	 locktagbuf;
+	StringInfoData	 local_clientbuf;	/* Local buffer common to clientbuf and localbuf */
+
+	DEADLOCK_INFO	*info;
+	DEADLOCK_INFO	*next_info;
+	LOCAL_WFG		*local_wfg;
+	int64			 my_db_id;
+	int64			 next_db_id;
+	int				 ii;
+
+	if (global_deadlock_info == NULL)
+		elog(ERROR, "No global deadlock info was found.\n");
+
+	initStringInfo(&clientbuf);
+	initStringInfo(&logbuf);
+	initStringInfo(&locktagbuf);
+	initStringInfo(&local_clientbuf);
+
+	for (ii = 0; ii < global_deadlock_info->nLocalWfg; ii++)
+	{
+		int				 jj;
+
+		/* Each local WFG */
+
+		my_db_id = global_deadlock_info->local_wfg[ii]->database_system_identifier;
+
+		if (ii != (global_deadlock_info->nLocalWfg - 1))
+			next_db_id = global_deadlock_info->local_wfg[ii + 1]->database_system_identifier;
+		else
+			next_db_id = global_deadlock_info->local_wfg[0]->database_system_identifier;
+		local_wfg = global_deadlock_info->local_wfg[ii];
+
+		resetStringInfo(&local_clientbuf);
+		appendStringInfo(&local_clientbuf,
+						_("\nDeadlock info for Database system id: %016lx,  "),
+						my_db_id);
+
+		for (jj = 0; jj < local_wfg->nDeadlockInfo; jj++)
+		{
+			resetStringInfo(&locktagbuf);
+			info = &local_wfg->deadlock_info[jj];
+
+			DescribeLockTag(&locktagbuf, &info->locktag);
+			if (local_wfg->deadlock_info[jj].locktag.locktag_type == LOCKTAG_EXTERNAL)
+			{
+				/*
+				 * Please note that last cyle information is included in global deadlock info.
+				 * We don't have to visit the first menber of local wait-for-graph if no
+				 * external lock is involved.
+				 */
+				ExternalLockInfo	*ext_lock = global_deadlock_info->local_wfg[ii]->external_lock;
+				info = &local_wfg->deadlock_info[jj];
+
+				appendStringInfo(&local_clientbuf,
+								_("Process %d waits for remote database %016lx, process %d.  "),
+								info->pid, next_db_id, ext_lock->target_pid);
+			}
+			else
+			{
+				Assert(jj < (local_wfg->nDeadlockInfo - 1));
+
+				next_info = &local_wfg->deadlock_info[jj + 1];
+				appendStringInfo(&local_clientbuf,
+							_("Process %d waits for %s on %s; blocked by process %d.  "),
+							info->pid,
+							GetLockmodeName(info->locktag.locktag_lockmethodid,
+											info->lockmode),
+							locktagbuf.data,
+							next_info->pid);
+			}
+		}
+		appendStringInfoString(&clientbuf, local_clientbuf.data);
+		appendStringInfoString(&logbuf, local_clientbuf.data);
+		for (jj = 0; jj < local_wfg->nDeadlockInfo; jj++)
+		{
+			appendStringInfo(&logbuf,
+						    _("Process %d query: \"%s\" "),
+						    local_wfg->deadlock_info[jj].pid,
+						    local_wfg->backend_activity[jj]);
+		}
+	}
+
+	/*
+	 * K.Suzuki: At present, we are reporting same deadlock to pgstat.
+	 */
+	pgstat_report_deadlock();
+
+	/* Until query datails are available, client message is the same as server log.  TDB */
+	ereport(ERROR,
+			(errcode(ERRCODE_T_R_DEADLOCK_DETECTED),
+			 errmsg("global deadlock detected"),
+			 errdetail_internal("%s", clientbuf.data),
+			 errdetail_log("%s", logbuf.data),
+			 errhint("See server log for query details.")));
+}
+
+static void *
+gdd_repalloc(void *pointer, Size size)
+{
+	if (pointer == NULL)
+		return palloc(size);
+	else
+		return repalloc(pointer, size);
+}
diff --git a/src/backend/storage/lmgr/libpqgddcheckremote/Makefile b/src/backend/storage/lmgr/libpqgddcheckremote/Makefile
new file mode 100644
index 0000000000..2a4781d6c9
--- /dev/null
+++ b/src/backend/storage/lmgr/libpqgddcheckremote/Makefile
@@ -0,0 +1,35 @@
+#-------------------------------------------------------------------------
+#
+# Makefile--
+#    Makefile for src/backend/storage/lmgr/libpqgddcheckremote
+#
+# IDENTIFICATION
+#    src/backend/storage/lmgr/libpqgddcheckremote/Makefile
+#
+#-------------------------------------------------------------------------
+
+subdir = src/backend/storage/lmgr/libpqgddcheckremote
+top_builddir = ../../../../..
+include $(top_builddir)/src/Makefile.global
+
+override CPPFLAGS := -I$(srcdir) -I$(libpq_srcdir) $(CPPFLAGS)
+
+OBJS = libpqgddcheckremote.o $(WIN32RES)
+SHLIB_LINK_INTERNAL = $(libpq)
+SHLIB_LINK = $(filter -lintl, $(LIBS))
+SHLIB_PREREQS = submake-libpq
+PGFILEDESC = "libpqgddcheckremote - global deadlock check - trace remote wait-for-graph"
+NAME = libpqgddcheckremote
+
+all: all-shared-lib
+
+include $(top_srcdir)/src/Makefile.shlib
+
+install: all installdirs install-lib
+
+installdirs: installdirs-lib
+
+uninstall: uninstall-lib
+
+clean distclean maintainer-clean: clean-lib
+	rm -f $(OBJS)
diff --git a/src/backend/storage/lmgr/libpqgddcheckremote/libpqgddcheckremote.c b/src/backend/storage/lmgr/libpqgddcheckremote/libpqgddcheckremote.c
new file mode 100644
index 0000000000..06f154666b
--- /dev/null
+++ b/src/backend/storage/lmgr/libpqgddcheckremote/libpqgddcheckremote.c
@@ -0,0 +1,99 @@
+/*-----------------------------------------------------------------------------------------------------
+ *
+ * libpqgddcheckremote.c
+
+ *	libapqgddcheckremote.c is an interface function to use libpq from the backend.
+ *  This is using similar strategy as in libpqwalreceiver.c
+ *
+ * Portions Copyright (c) 2020, 2ndQUadrant Ltd.,
+ * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
+ *
+ * IDENTIFICATION
+ *   sec/backend/storage/lmgr/libpqgddcheckremote/libpqgddcheckremote.c
+ *-----------------------------------------------------------------------------------------------------
+ */
+#include "postgres.h"
+
+#include <unistd.h>
+#include <sys/time.h>
+
+#include "libpq-fe.h"
+#include "access/xlog.h"
+#include "catalog/pg_type.h"
+#include "funcapi.h"
+#include "mb/pg_wchar.h"
+#include "miscadmin.h"
+#include "pgstat.h"
+#include "storage/global_deadlock.h"
+#include "utils/builtins.h"
+#include "utils/memutils.h"
+
+PG_MODULE_MAGIC;
+
+void		_PG_init(void);
+static RETURNED_WFG *pg_gdd_check_remote(const char *connstr, char *wfg);
+static PGconn *gdd_check_connect(const char *connstr);
+
+void
+_PG_init(void)
+{
+	if (pg_gdd_check_func != NULL)
+		elog(ERROR, "libpqgddcheckremote already loaded");
+	pg_gdd_check_func = pg_gdd_check_remote;
+}
+
+static RETURNED_WFG *
+pg_gdd_check_remote(const char *connstr, char *wfg)
+{
+	PGconn		*conn;
+	PGresult	*res;
+	StringInfoData	query;
+	StringInfoData	rv;
+	RETURNED_WFG	*returning_wfg;
+	int			 nTuples;
+	int			 ii;
+
+	initStringInfo(&query);
+	initStringInfo(&rv);
+	appendStringInfo(&query, "SELECT * FROM pg_global_deadlock_check_from_remote($GDD$%s$GDD$);", wfg);
+	conn = gdd_check_connect(connstr);
+	res = PQexec(conn, query.data);
+	pfree(query.data);
+	query.data = NULL;
+	if (res == NULL || PQresultStatus(res) != PGRES_TUPLES_OK)
+		elog(ERROR, "Cannot run remote query to check global deadlock. %s\n",
+					res ? PQresultErrorMessage(res) : "");
+	nTuples = PQntuples(res);
+
+	returning_wfg = (RETURNED_WFG *)palloc(sizeof(RETURNED_WFG));
+	returning_wfg->nReturnedWfg = nTuples;
+	returning_wfg->state = (DeadLockState *)palloc(sizeof(DeadLockState) * nTuples);
+	returning_wfg->global_wfg_in_text = (char **)palloc(sizeof(char *) * nTuples);
+
+	for (ii = 0; ii < nTuples; ii++)
+	{
+		char		*state_s;
+
+		state_s = PQgetvalue(res, ii, 0);
+		returning_wfg->state[ii] = atoi(state_s);
+		returning_wfg->global_wfg_in_text[ii] = pstrdup(PQgetvalue(res, ii, 1));
+	}
+	PQclear(res);
+	PQfinish(conn);
+	return returning_wfg;
+}
+
+static PGconn *
+gdd_check_connect(const char *connstr)
+{
+	PGconn *conn;
+
+	conn = PQconnectdb(connstr);
+	if (conn == NULL || PQstatus(conn) == CONNECTION_BAD)
+	{
+		elog(ERROR, "Failed to connect to remote database '%s' not reacheable.",
+				connstr);
+		return NULL;
+	}
+	return conn;
+}
diff --git a/src/backend/storage/lmgr/lmgr.c b/src/backend/storage/lmgr/lmgr.c
index 889841f4cc..6653aa31a7 100644
--- a/src/backend/storage/lmgr/lmgr.c
+++ b/src/backend/storage/lmgr/lmgr.c
@@ -1153,6 +1153,14 @@ DescribeLockTag(StringInfo buf, const LOCKTAG *tag)
 							 tag->locktag_field3,
 							 tag->locktag_field4);
 			break;
+		case LOCKTAG_EXTERNAL:
+			appendStringInfo(buf,
+							 _("exetrnal lock [%u,%u,%u,%u]"),
+							 tag->locktag_field1,
+							 tag->locktag_field2,
+							 tag->locktag_field3,
+							 tag->locktag_field4);
+			break;
 		default:
 			appendStringInfo(buf,
 							 _("unrecognized locktag type %d"),
diff --git a/src/backend/storage/lmgr/lock.c b/src/backend/storage/lmgr/lock.c
index 6745a2432e..12b2f1657c 100644
--- a/src/backend/storage/lmgr/lock.c
+++ b/src/backend/storage/lmgr/lock.c
@@ -3,7 +3,7 @@
  * lock.c
  *	  POSTGRES primary lock mechanism
  *
- * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
+ * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  *
@@ -19,17 +19,58 @@
  *	  For the most part, this code should be invoked via lmgr.c
  *	  or another lock-management module, not directly.
  *
+ * Notes for additional lock type
+ *
+ *	  Added lock type EXTERNAL_LOCK for global deadlock detection.
+ *	  This represents remote transaction which the backend is waiting
+ *	  for.
+ *
+ *    Because blocking backend is not in this postgres instance,
+ *	  this lock is held by the waiting backend and is waited by the same
+ *	  backend.
+ *
+ *    For this, EXTERNAL_LOCK needs dedicated API to handle.
+ *    These API are used by deadlock detection internals and modules
+ *	  which issue remote transactions.
+ *
+ *	  Because EXTERNAL LOCK represents dependency of the backend on
+ *    a remote transaction, LOCK is held by the backend and waited
+ *	  by the same backend.
+ *
+ *    For this reason, it is not recommended to handle EXTERNAL_LOCK
+ *    with existing low leven API.
+ *
+ *    This lock is used to find the backend is waiting for a remote
+ *	  transaction and hence to track global wait-for-graph.
+ *
+ *    Deadlock detection mechanism (DeadLockCheck() in deadlock.c)
+ *    is used to detect this.   For details, please take a look at
+ *	  comments of deadlock.c.
+ *
  *	Interface:
  *
  *	InitLocks(), GetLocksMethodTable(), GetLockTagsMethodTable(),
  *	LockAcquire(), LockRelease(), LockReleaseAll(),
  *	LockCheckConflicts(), GrantLock()
  *
+ * Interface for external lock:
+ *
+ *  set_locktag_external(), ExternalLockAcquire(), ExternalLockRelease(),
+ *  ExternalLockUnWaitProc(), ExternalLockUnWait(), ExernalLockWait(),
+ *  ExternalLockWaitProc(), ExternalLockSetProperties(),
+ *  GetExternalLockProperties(), FreeExternalLockProperties()
+ *
+ * K.Suzuki
+ *  We don't check strictly if LOCKTAG (in this case, EXTERNAL_LOCK, especially)
+ *  is in lock table.   Expects callers use external lock functions properly.
+ *
  *-------------------------------------------------------------------------
  */
 #include "postgres.h"
 
 #include <signal.h>
+#include <sys/stat.h>
+#include <sys/types.h>
 #include <unistd.h>
 
 #include "access/transam.h"
@@ -53,10 +94,12 @@
 /* This configuration variable is used to set the lock table size */
 int			max_locks_per_xact; /* set by guc.c */
 
+/* GUC parameter to enable global deadlock detection */
+bool	enable_global_deadlock_detection;
+
 #define NLOCKENTS() \
 	mul_size(max_locks_per_xact, add_size(MaxBackends, max_prepared_xacts))
 
-
 /*
  * Data structures defining the semantics of the standard lock methods.
  *
@@ -213,6 +256,16 @@ static bool FastPathUnGrantRelationLock(Oid relid, LOCKMODE lockmode);
 static bool FastPathTransferRelationLocks(LockMethod lockMethodTable,
 										  const LOCKTAG *locktag, uint32 hashcode);
 static PROCLOCK *FastPathGetRelationLockEntry(LOCALLOCK *locallock);
+/*
+ * Additional functions to support external lock.
+ */
+static bool checkExternalLockTag(const LOCKTAG *locktag, PGPROC *proc);
+static bool externalLockFileUnlink(LOCKTAG *locktag);
+static bool externalLockFileUnlinkProc(const LOCKTAG *locktag, PGPROC *proc);
+static LOCK *findExternalLock(const LOCKTAG *locktag);
+static char *findExternalLockFileName(const LOCKTAG *locktag);
+ExternalLockInfo *GetExternalLockProperties(const LOCKTAG *locktag);
+static bool read_line(FILE *f, StringInfo s);
 
 /*
  * To make the fast-path lock mechanism work, we must have some way of
@@ -360,6 +413,9 @@ static void LockRefindAndRelease(LockMethod lockMethodTable, PGPROC *proc,
 static void GetSingleProcBlockerStatusData(PGPROC *blocked_proc,
 										   BlockedProcsData *data);
 
+/* Additional function for external lock */
+static bool externalLockFileUnlinkProc(const LOCKTAG *locktag, PGPROC *proc);
+
 
 /*
  * InitLocks -- Initialize the lock manager's data structures.
@@ -1548,6 +1604,23 @@ CleanUpLock(LOCK *lock, PROCLOCK *proclock,
 			LockMethod lockMethodTable, uint32 hashcode,
 			bool wakeupNeeded)
 {
+	/*
+	 * Unlink External lock property file.
+	 */
+	if (lock->tag.locktag_type == LOCKTAG_EXTERNAL)
+	{
+		/*
+		 * Exernal Lock may be associated with property file.   We need to clean this
+		 * up too.
+		 */
+		char	*pfname;
+
+		pfname = findExternalLockFileName(&(lock->tag));
+		if (pfname)
+			unlink(pfname);
+		pfree(pfname);
+	}
+
 	/*
 	 * If this was my last hold on this lock, delete my entry in the proclock
 	 * table.
@@ -4494,3 +4567,362 @@ LockWaiterCount(const LOCKTAG *locktag)
 
 	return waiters;
 }
+
+/*
+ * ---------------------------------------------------------------------------------
+ *
+ * Dedicated API for external lock.
+ *
+ * ---------------------------------------------------------------------------------
+ */
+#define get_leader_proc(proc) \
+	((proc)->lockGroupLeader ? (proc)->lockGroupLeader : proc)
+
+/*
+ *set_locktag_external
+ *
+ * Set LOCKTAG for external lock
+ */
+void
+set_locktag_external(LOCKTAG *locktag, PGPROC *proc, bool incr)
+{
+	PGPROC *leader;
+	Assert(locktag);
+
+	leader = get_leader_proc(proc);
+	locktag->locktag_field1 = leader->pgprocno;
+	locktag->locktag_field2 = leader->pid;
+	locktag->locktag_field3 = proc->lxid;
+	locktag->locktag_field4 = leader->external_lock_no;
+	locktag->locktag_type = LOCKTAG_EXTERNAL;
+	locktag->locktag_lockmethodid = DEFAULT_LOCKMETHOD;
+	if (incr)
+		leader->external_lock_no++;
+	return;
+}
+
+
+LockAcquireResult
+ExternalLockAcquire(PGPROC *proc, LOCKTAG *locktag)
+{
+	LockAcquireResult	rv;
+	PGPROC *leader;
+
+	Assert(locktag);
+	Assert(proc);
+
+	leader = get_leader_proc(proc);
+	locktag->locktag_field1 = leader->pgprocno;
+	locktag->locktag_field2 = leader->pid;
+	locktag->locktag_field3 = proc->lxid;
+	locktag->locktag_field4 = leader->external_lock_no;
+	locktag->locktag_type = LOCKTAG_EXTERNAL;
+	locktag->locktag_lockmethodid = DEFAULT_LOCKMETHOD;
+
+	rv =  LockAcquireExtended(locktag, AccessExclusiveLock, false, true,
+							   true, NULL);
+	if (rv == LOCKACQUIRE_OK)
+		leader->external_lock_no++;
+	return rv;
+}
+
+bool
+ExternalLockRelease(LOCKTAG *locktag)
+{
+	bool rv;
+
+	rv = LockRelease(locktag, AccessExclusiveLock, false);
+	if (rv != true)
+		return rv;
+	externalLockFileUnlink(locktag);
+	return rv;
+}
+
+bool
+ExternalLockUnWaitProc(const LOCKTAG *locktag, PGPROC *proc)
+{
+	if (!proc->waitLock)
+		return false;
+	if (memcmp(locktag, &(proc->waitLock->tag), sizeof(LOCKTAG)))
+		return false;
+	if (checkExternalLockTag(locktag, proc) != true)
+		return false;
+	proc->waitLock = NULL;
+	proc->waitLockMode = NoLock;
+	return true;
+}
+
+bool
+ExternalLockUnWait(const LOCKTAG *locktag)
+{
+	return ExternalLockUnWaitProc(locktag, MyProc);
+}
+
+
+/*
+ * Check if given process is eligible to wait for given external lock
+ */
+static bool
+checkExternalLockTag(const LOCKTAG *locktag, PGPROC *proc)
+{
+	PGPROC *leader = get_leader_proc(proc);
+
+	if ((locktag->locktag_type != LOCKTAG_EXTERNAL) ||
+		(locktag->locktag_lockmethodid != DEFAULT_LOCKMETHOD))
+		return false;
+	if ((locktag->locktag_field1 != leader->pgprocno) ||
+		(locktag->locktag_field2 != leader->pid) ||
+		(locktag->locktag_field3 != proc->lxid))
+		return false;
+	if (locktag->locktag_field4 > leader->external_lock_no)
+		return false;
+	if (findExternalLock(locktag) == NULL)
+		return false;
+	return true;
+}
+
+/*
+ * Set external lock as "Waiting"
+ */
+bool
+ExternalLockWait(const LOCKTAG *locktag)
+{
+	return ExternalLockWaitProc(locktag, MyProc);
+}
+
+bool
+ExternalLockWaitProc(const LOCKTAG *locktag, PGPROC *proc)
+{
+	LOCK	*lock;
+	
+	if (checkExternalLockTag(locktag, proc) != true)
+	{
+		elog(ERROR, "Locktag type error.  Should be LOCKTAG_EXTERNAL\n");
+		return false;
+	}
+	lock = findExternalLock(locktag);
+	if (lock == NULL)
+		/* Specified lock does not exist */
+		return false;
+	if (proc->waitLock != NULL)
+	{
+		/* Already wating for some lock. Internal eror. */
+		elog(ERROR, "Process is already waiting for another lock.\n");
+		return false;
+	}
+	proc->waitLock = lock;
+	proc->waitLockMode = AccessExclusiveLock;
+	return true;
+}
+
+bool
+ExternalLockSetProperties(LOCKTAG *locktag,
+						  PGPROC *proc,
+						  char *dsn,
+						  int target_pgprocno,
+						  int target_pid,
+						  TransactionId target_xid,
+						  bool update_flag)
+{
+	char			*lockFname;
+	StringInfoData	 externalLockFileData;
+	struct stat		 statbuf;
+	FILE			*lockF;
+
+	/*
+	 * Check if locktag and proc satisfy the eligibility.
+	 */
+	if (checkExternalLockTag(locktag, proc) != true)
+		return false;
+
+	lockFname = findExternalLockFileName(locktag);
+	/*
+	 * Check if the target file exists
+	 */
+	if (stat(lockFname, &statbuf) == 0)
+	{
+		if (update_flag == false)
+		{
+			pfree(lockFname);
+			return false;
+		}
+		if (statbuf.st_mode != S_IFREG)
+		{
+			pfree(lockFname);
+			elog(ERROR, "Specified external lock file is not a regular file.");
+			return false;
+		}
+	}
+	initStringInfo(&externalLockFileData);
+	appendStringInfo(&externalLockFileData, "%s\n%d\n%d\n%d\n", dsn, target_pgprocno, target_pid, target_xid);
+	lockF = AllocateFile(lockFname, "w");
+	if (lockF == 0)
+		elog(ERROR, "Could not open external lock file, %s", lockFname);
+	if (fwrite(externalLockFileData.data, externalLockFileData.len, 1, lockF) != 1)
+		elog(ERROR, "Could not write to external lock file, %s", lockFname);
+	FreeFile(lockF);
+	pfree(lockFname);
+	pfree(externalLockFileData.data);
+	return true;
+}
+
+/*
+ * This function is used by SQL function pg_external_lock_set().   This is defined in deadlock.c
+ *
+ * This sets external lock property for specified backend.   Specified backed must be waiting for
+ * an external lock.
+ */
+bool
+ExternalLockSetPropertiesWaiting(PGPROC *proc,
+								 char *dsn,
+								 int target_pgprocno,
+								 int target_pid,
+								 TransactionId target_xid,
+								 bool update_flag)
+{
+	LOCKTAG	*locktag;
+	LOCK	*waitlock;
+
+	Assert(proc);
+
+	waitlock = proc->waitLock;
+	if (waitlock == NULL)
+		elog(ERROR, "Specified proc has no waiting lock.");
+	locktag = &waitlock->tag;
+
+	Assert(locktag);
+	if (locktag->locktag_type != LOCKTAG_EXTERNAL)
+		elog(ERROR, "Specified proc is not waiting for external lock.");
+	return ExternalLockSetProperties(locktag, proc, dsn, target_pgprocno, target_pid, target_xid, update_flag);
+}
+
+ExternalLockInfo *
+GetExternalLockProperties(const LOCKTAG *locktag)
+{
+	FILE				*lockF;
+	ExternalLockInfo	*output;
+	StringInfoData		 linebuf;
+	char				*lockfname;
+
+	if (locktag->locktag_type != LOCKTAG_EXTERNAL)
+		return NULL;
+	lockfname = findExternalLockFileName(locktag);
+	lockF = AllocateFile(lockfname, "r");
+	if (lockF == NULL)
+		elog(ERROR, "Could not open external lock file, %s", lockfname);
+	pfree(lockfname);
+	output = (ExternalLockInfo *)palloc(sizeof(ExternalLockInfo));
+	output->pgprocno = locktag->locktag_field1;
+	output->pid = locktag->locktag_field2;
+	output->txnid = locktag->locktag_field3;
+	output->serno = locktag->locktag_field4;
+
+	/* read dsn */
+	initStringInfo(&linebuf);
+	resetStringInfo(&linebuf);
+	read_line(lockF, &linebuf);
+	output->dsn = pstrdup(linebuf.data);
+	/* Read target pgprocno */
+	resetStringInfo(&linebuf);
+	read_line(lockF, &linebuf);
+	output->target_pgprocno = atoi(linebuf.data);
+	/* Read target pid */
+	resetStringInfo(&linebuf);
+	read_line(lockF, &linebuf);
+	output->target_pid = atoi(linebuf.data);
+	/* Read target xid */
+	resetStringInfo(&linebuf);
+	read_line(lockF, &linebuf);
+	output->target_txn = atoi(linebuf.data);
+	FreeFile(lockF);
+	pfree(linebuf.data);
+	return output;
+}
+
+static char *
+findExternalLockFileName(const LOCKTAG *locktag)
+{
+	StringInfoData	fname;
+
+	initStringInfo(&fname);
+	appendStringInfo(&fname, "%s/pg_external_locks/%08x%08x%08x%08x",
+			DataDir, locktag->locktag_field1, locktag->locktag_field2,
+			locktag->locktag_field3, locktag->locktag_field4);
+	return fname.data;
+}
+
+static LOCK *
+findExternalLock(const LOCKTAG *locktag)
+{
+	bool	found;
+	LOCALLOCKTAG localtag;
+	LOCALLOCK  *locallock;
+
+	localtag.lock = *locktag;
+	localtag.mode = AccessExclusiveLock;
+
+	locallock = (LOCALLOCK *) hash_search(LockMethodLocalHash,
+										  (void *) &localtag,
+										  HASH_FIND, &found);
+	if (!found)
+		elog(DEBUG3, "No lock found. %%1: %d, %%2: %d, %%3: %d, %%4: %d, %%5: %d, %%6: %d",
+				locktag->locktag_field1, locktag->locktag_field2,
+				locktag->locktag_field3, locktag->locktag_field4,
+				locktag->locktag_type, locktag->locktag_lockmethodid);
+
+	return found ? locallock->lock : NULL;
+}
+
+static bool
+read_line(FILE *f, StringInfo s)
+{
+	char	inbuf;
+
+	while(true)
+	{
+		inbuf = getc(f);
+		if (inbuf < 0)
+			goto fmterr;
+		if (inbuf == '\n')
+			break;
+		appendStringInfoChar(s, inbuf);
+	}
+	return true;
+
+fmterr:
+	FreeFile(f);
+	elog(ERROR, "External lock file format error.");
+	return false;
+}
+
+void
+FreeExternalLockProperties(ExternalLockInfo *ext_lockinfo)
+{
+	if (ext_lockinfo->dsn)
+		pfree(ext_lockinfo->dsn);
+	pfree(ext_lockinfo);
+}
+
+
+static bool
+externalLockFileUnlinkProc(const LOCKTAG *locktag, PGPROC *proc)
+{
+	char *externalLockFilePath;
+	int	rv;
+
+	if (checkExternalLockTag(locktag, proc) == true)
+		return false;
+
+	externalLockFilePath = findExternalLockFileName(locktag);
+
+	rv = unlink(externalLockFilePath);
+	pfree(externalLockFilePath);
+	return (rv == 0 ? true : false);
+}
+
+static bool
+externalLockFileUnlink(LOCKTAG *locktag)
+{
+	return(externalLockFileUnlinkProc(locktag, MyProc));
+}
+
diff --git a/src/backend/storage/lmgr/proc.c b/src/backend/storage/lmgr/proc.c
index 498373fd0e..5785e0cc49 100644
--- a/src/backend/storage/lmgr/proc.c
+++ b/src/backend/storage/lmgr/proc.c
@@ -32,8 +32,8 @@
 #include "postgres.h"
 
 #include <signal.h>
-#include <unistd.h>
 #include <sys/time.h>
+#include <unistd.h>
 
 #include "access/transam.h"
 #include "access/twophase.h"
@@ -94,6 +94,8 @@ static void RemoveProcFromArray(int code, Datum arg);
 static void ProcKill(int code, Datum arg);
 static void AuxiliaryProcKill(int code, Datum arg);
 static void CheckDeadLock(void);
+static void acquire_all_lockline(void);
+static void release_all_lockline(void);
 
 
 /*
@@ -1689,8 +1691,6 @@ ProcLockWakeup(LockMethod lockMethodTable, LOCK *lock)
 static void
 CheckDeadLock(void)
 {
-	int			i;
-
 	/*
 	 * Acquire exclusive lock on the entire shared lock data structures. Must
 	 * grab LWLocks in partition-number order to avoid LWLock deadlock.
@@ -1701,8 +1701,7 @@ CheckDeadLock(void)
 	 * section, so that this routine cannot be interrupted by cancel/die
 	 * interrupts.
 	 */
-	for (i = 0; i < NUM_LOCK_PARTITIONS; i++)
-		LWLockAcquire(LockHashPartitionLockByIndex(i), LW_EXCLUSIVE);
+	acquire_all_lockline();
 
 	/*
 	 * Check to see if we've been awoken by anyone in the interim.
@@ -1754,6 +1753,25 @@ CheckDeadLock(void)
 		 * RemoveFromWaitQueue took care of waking up any such processes.
 		 */
 	}
+	else if (deadlock_state == DS_EXTERNAL_LOCK)
+	{
+		/*
+		 * K.Suzuki: Release LWLocks to wait for remote site deadlock check
+		 */
+		release_all_lockline();
+		deadlock_state = GlobalDeadlockCheck(MyProc);
+		acquire_all_lockline();
+		if (deadlock_state == DS_HARD_DEADLOCK)
+		{
+			Assert(MyProc->waitLock != NULL);
+			RemoveFromWaitQueue(MyProc, LockTagHashCode(&(MyProc->waitLock->tag)));
+		}
+		else if (deadlock_state == DS_GLOBAL_ERROR)
+		{
+			release_all_lockline();
+			elog(ERROR, "Internal error in global deadlock detection.");
+		}
+	}
 
 	/*
 	 * And release locks.  We do this in reverse order for two reasons: (1)
@@ -1763,10 +1781,28 @@ CheckDeadLock(void)
 	 * behavior inside LWLockRelease.
 	 */
 check_done:
-	for (i = NUM_LOCK_PARTITIONS; --i >= 0;)
-		LWLockRelease(LockHashPartitionLockByIndex(i));
+	release_all_lockline();
 }
 
+static void
+acquire_all_lockline(void)
+{
+	int ii;
+
+	for (ii = 0; ii < NUM_LOCK_PARTITIONS; ii++)
+	LWLockAcquire(LockHashPartitionLockByIndex(ii), LW_EXCLUSIVE);
+}
+
+static void
+release_all_lockline(void)
+{
+	int ii;
+
+	for (ii = 0; ii < NUM_LOCK_PARTITIONS; ii++)
+	LWLockRelease(LockHashPartitionLockByIndex(ii));
+}
+
+
 /*
  * CheckDeadLockAlert - Handle the expiry of deadlock_timeout.
  *
diff --git a/src/backend/utils/adt/lockfuncs.c b/src/backend/utils/adt/lockfuncs.c
index ffd1970f58..2a28548a8a 100644
--- a/src/backend/utils/adt/lockfuncs.c
+++ b/src/backend/utils/adt/lockfuncs.c
@@ -32,6 +32,7 @@ const char *const LockTagTypeNames[] = {
 	"virtualxid",
 	"speculative token",
 	"object",
+	"external",
 	"userlock",
 	"advisory"
 };
diff --git a/src/bin/initdb/initdb.c b/src/bin/initdb/initdb.c
index acf610808e..e63eaf9d76 100644
--- a/src/bin/initdb/initdb.c
+++ b/src/bin/initdb/initdb.c
@@ -222,7 +222,8 @@ static const char *const subdirs[] = {
 	"pg_xact",
 	"pg_logical",
 	"pg_logical/snapshots",
-	"pg_logical/mappings"
+	"pg_logical/mappings",
+	"pg_external_locks"
 };
 
 
diff --git a/src/include/catalog/pg_proc.dat b/src/include/catalog/pg_proc.dat
index d352f9a10a..a5ba6bdbd7 100644
--- a/src/include/catalog/pg_proc.dat
+++ b/src/include/catalog/pg_proc.dat
@@ -10676,4 +10676,18 @@
   proname => 'pg_partition_root', prorettype => 'regclass',
   proargtypes => 'regclass', prosrc => 'pg_partition_root' },
 
+# functions used in global deadlock detection internals
+{ oid => '6122', descr => 'global deadlock check for remote transaction',
+  proname => 'pg_global_deadlock_check_from_remote', procost => '10',
+  provolatile => 'v', prorettype => 'record', proargtypes => 'cstring',
+  prorows => '1', proretset => 't', proallargtypes => '{cstring,int4,text}', proargmodes => '{i,o,o}',
+  proargnames => '{wfg_in,deadlock_state,wfg_out}',
+  prosrc => 'pg_global_deadlock_check_from_remote' },
+{ oid => '6123', descr => 'obtain target process properties for global deadlock check setup',
+  proname => 'pg_global_deadlock_check_describe_backend', procost => '10',
+  provolatile => 'v', prorettype => 'record', proargtypes => 'int4',
+  proallargtypes => '{int4,int4,int4,numeric}', proargmodes => '{i,o,o,o}',
+  proargnames => '{pid-in,pid,pgprocno,lxid}',
+  prosrc => 'pg_global_deadlock_check_describe_backend' },
+
 ]
diff --git a/src/include/storage/global_deadlock.h b/src/include/storage/global_deadlock.h
new file mode 100644
index 0000000000..cef3da6c68
--- /dev/null
+++ b/src/include/storage/global_deadlock.h
@@ -0,0 +1,34 @@
+#ifndef GLOBAL_DEADLOCK_H
+#define GLOBAL_DEADLOCK_H
+
+/*
+ * Interface functions
+ *
+ */
+
+#include "postgres.h"
+
+#include "storage/lock.h"
+
+/*
+ * The following represents discovered candidate of wait-for-graph segment.
+ * This was used in several global deadlock detection functions.
+ *
+ * By checking Wfg stability locally at downstream database, number of global_wfg_in_text
+ * is practically one.
+ */
+typedef struct RETURNED_WFG
+{
+    int               nReturnedWfg;
+    DeadLockState    *state;                /* DS_HARD_DEADLOCK or DS_EXTERNL_LOCK */
+    char            **global_wfg_in_text;   /* Text-format global wait-for-graph discovered */
+} RETURNED_WFG;
+
+
+typedef RETURNED_WFG	*(gdd_check_fn) (const char *conninfo, char *wfg);
+
+extern PGDLLIMPORT gdd_check_fn	*pg_gdd_check_func;
+
+#define gdd_check(conninfo, wfg)	pg_gdd_check_func(conninfo, wfg)
+
+#endif /* GLOBAL_DEADLOCK_H */
diff --git a/src/include/storage/libpqgddcheckremote.h b/src/include/storage/libpqgddcheckremote.h
new file mode 100644
index 0000000000..251077bba2
--- /dev/null
+++ b/src/include/storage/libpqgddcheckremote.h
@@ -0,0 +1,10 @@
+#ifndef LIBPQGDDCHECKREMOTE_H
+#define LIBPQGDDCHECKREMOTE_H
+
+typedef char *(*pg_gdd_check_f) (char *connstr, char *wfg);
+
+extern PGDLLIMPORT pg_gdd_check_f	pg_gdd_check_function;
+
+#define pg_gdd_check(c)	pg_gdd_check_function(c);
+
+#endif /* LIBPQGDDCHECKREMOTE_H */
diff --git a/src/include/storage/lock.h b/src/include/storage/lock.h
index 986bb6433a..65a229fc65 100644
--- a/src/include/storage/lock.h
+++ b/src/include/storage/lock.h
@@ -145,10 +145,18 @@ typedef enum LockTagType
 	LOCKTAG_VIRTUALTRANSACTION, /* virtual transaction (ditto) */
 	LOCKTAG_SPECULATIVE_TOKEN,	/* speculative insertion Xid and token */
 	LOCKTAG_OBJECT,				/* non-relation database object */
+	LOCKTAG_EXTERNAL,           /* External lock to represent child remote transaction */
+								/* ID info for an external txn is pgprocno, pid, xid and serial no. */
+								/* All the above is taken from the lock group leader */
 	LOCKTAG_USERLOCK,			/* reserved for old contrib/userlock code */
 	LOCKTAG_ADVISORY			/* advisory user locks */
 } LockTagType;
 
+/*
+ * Encapsulation of DEADLOCK_INFO
+ */
+typedef struct DEADLOCK_INFO DEADLOCK_INFO;
+
 #define LOCKTAG_LAST_TYPE	LOCKTAG_ADVISORY
 
 extern const char *const LockTagTypeNames[];
@@ -472,6 +480,18 @@ typedef struct BlockedProcsData
 } BlockedProcsData;
 
 
+typedef struct ExternalLockInfo
+{
+	int			pid;
+	int			pgprocno;
+	LocalTransactionId	txnid;
+	int			serno;
+	char	   *dsn;
+	int			target_pid;
+	int			target_pgprocno;
+	LocalTransactionId	target_txn;
+} ExternalLockInfo;
+
 /* Result codes for LockAcquire() */
 typedef enum
 {
@@ -488,10 +508,69 @@ typedef enum
 	DS_NO_DEADLOCK,				/* no deadlock detected */
 	DS_SOFT_DEADLOCK,			/* deadlock avoided by queue rearrangement */
 	DS_HARD_DEADLOCK,			/* deadlock, no way out but ERROR */
-	DS_BLOCKED_BY_AUTOVACUUM	/* no deadlock; queue blocked by autovacuum
+	DS_BLOCKED_BY_AUTOVACUUM,	/* no deadlock; queue blocked by autovacuum
 								 * worker */
+	DS_EXTERNAL_LOCK,			/* waiting for remote transaction, need global
+								 * deadlock detection */
+	DS_DEADLOCK_INFO,			/* Set of deadlock/external_lock information is available.
+								 * Internal use */
+	DS_GLOBAL_ERROR				/* Used only to report internal error in global deadlock detection */
 } DeadLockState;
 
+
+/*
+ * Information saved about each edge in a detected deadlock cycle.  This
+ * is used to print a diagnostic message upon failure.
+ *
+ * Note: because we want to examine this info after releasing the lock
+ * manager's partition locks, we can't just store LOCK and PGPROC pointers;
+ * we must extract out all the info we want to be able to print.
+ */
+
+#define WfG_HAS_EXTERNAL_LOCK	0x00000001
+#define WfG_HAS_VISITED_PROC	0x00000002
+
+/* Used in serialized global/local wait-for-graph */
+#define WfG_GLOBAL_MAGIC		0x80800001
+#define WfG_LOCAL_MAGIC			0x80880001
+
+typedef struct DEADLOCK_INFO
+{
+    LOCKTAG     locktag;        /* ID of awaited lock object */
+    LOCKMODE    lockmode;       /* type of lock we're waiting for */
+    int         pid;            /* PID of blocked backend */
+    /*
+     * K.Suzuki: The following is used for global deadlock detection.
+     *           These information is backed up here to check if there are no change
+     *           in PID and TXID and Wait-for-graph is globally stable.
+     */
+    int         pgprocno;       /* PGPROC index of the blocked backend */
+    TransactionId   txid;       /* Transacito ID of the blocked backend */
+} DEADLOCK_INFO;
+
+typedef struct LOCAL_WFG
+{
+	int32			 	  local_wfg_flag;
+	int64			 	  database_system_identifier;
+	int32				  visitedProcPid;		/* PID of visitedProc[0], exist only in the origin node */
+	int32			      visitedProcPgprocno;	/* pgprocno of visitedProc[0], exist only in the origin node */
+	int32				  visitedProcLxid;		/* lxid of visitedProc[0], exist only in the origin node */
+	int32			 	  nDeadlockInfo;
+	DEADLOCK_INFO		 *deadlock_info;
+	char				**backend_activity;		/* Each backend's activity in deadlock_info[] above. */
+	ExternalLockInfo	 *external_lock;
+} LOCAL_WFG;
+
+/*
+ * local_wfg[0] represents the local wait-for-graph for origine database.  local_wfg[1] represents
+ * the next downstream database.
+ */
+typedef struct GLOBAL_WFG
+{
+	int32	  	  nLocalWfg;	/* Number of local wait-for-graph in this global wait-for-graph */
+	LOCAL_WFG	**local_wfg;	/* Local wait-for-graph for each database.  Local_wfg[0] represents origin */
+} GLOBAL_WFG;
+
 /*
  * The lockmgr's shared hash tables are partitioned to reduce contention.
  * To determine which partition a given locktag belongs to, compute the tag's
@@ -518,6 +597,12 @@ typedef enum
 #define LockHashPartitionLockByProc(leader_pgproc) \
 	LockHashPartitionLock((leader_pgproc)->pgprocno)
 
+#define CompleteExternalLock(l) \
+	do { (l)->locktag_type = LOCKTAG_EXTERNAL; \
+		 (l)->locktag_lockmethodid = DEFAULT_LOCKMETHOD; \
+	} while (0)
+
+
 /*
  * function prototypes
  */
@@ -583,15 +668,45 @@ extern void RememberSimpleDeadLock(PGPROC *proc1,
 extern void InitDeadLockChecking(void);
 
 extern int	LockWaiterCount(const LOCKTAG *locktag);
+DEADLOCK_INFO *GetDeadLockInfo(int *nInfo);
+
 
 #ifdef LOCK_DEBUG
 extern void DumpLocks(PGPROC *proc);
 extern void DumpAllLocks(void);
 #endif
 
+/* GUC to control global deadlock detection */
+extern bool enable_global_deadlock_detection;
+
 /* Lock a VXID (used to wait for a transaction to finish) */
 extern void VirtualXactLockTableInsert(VirtualTransactionId vxid);
 extern void VirtualXactLockTableCleanup(void);
 extern bool VirtualXactLock(VirtualTransactionId vxid, bool wait);
 
+/* Functions for External Lock */
+extern	uint64	get_database_system_id(void);
+extern	const char *locktagTypeName(LockTagType type);
+extern	void	set_locktag_external(LOCKTAG *locktag, PGPROC *proc, bool incr);
+extern	LockAcquireResult ExternalLockAcquire(PGPROC *proc, LOCKTAG *locktag);
+extern	bool	ExternalLockRelease(LOCKTAG *locktag);
+extern	bool	ExternalLockWaitProc(const LOCKTAG *locktag, PGPROC *proc);
+extern	bool	ExternalLockWait(const LOCKTAG *locktag);
+extern	bool	ExternalLockUnWaitProc(const LOCKTAG *locktag, PGPROC *proc);
+extern	bool	ExternalLockUnWait(const LOCKTAG *locktag);
+extern	bool	ExternalLockSetProperties(LOCKTAG *locktag,
+					PGPROC *proc, char *dsn, int target_pgprocno,
+					int target_pid, TransactionId target_xid, bool update_flag);
+extern DEADLOCK_INFO *BuildLocalDeadlockInfo(int *nInfo);
+extern ExternalLockInfo *GetExternalLockProperties(const LOCKTAG *locktag);
+extern void FreeExternalLockProperties(ExternalLockInfo *ext_lockinfo);
+extern bool ExternalLockSetPropertiesWaiting(PGPROC *proc, char *dsn,
+					int target_pgprocno, int target_pid, TransactionId target_xid,
+					bool update_flag);
+
+
+/* Functions for Global deadlock detection */
+
+extern DeadLockState GlobalDeadlockCheck(PGPROC *proc);
+
 #endif							/* LOCK_H */
diff --git a/src/include/storage/proc.h b/src/include/storage/proc.h
index 43d0854a41..c61c23ee64 100644
--- a/src/include/storage/proc.h
+++ b/src/include/storage/proc.h
@@ -203,6 +203,7 @@ struct PGPROC
 	PGPROC	   *lockGroupLeader;	/* lock group leader, if I'm a member */
 	dlist_head	lockGroupMembers;	/* list of members, if I'm a leader */
 	dlist_node	lockGroupLink;	/* my member link, if I'm a member */
+	int         external_lock_no;   /* Serial number of external lock */
 };
 
 /* NOTE: "typedef struct PGPROC PGPROC" appears in storage/lock.h. */
diff --git a/src/test/regress/expected/opr_sanity.out b/src/test/regress/expected/opr_sanity.out
index 500184c1c5..b540421f1e 100644
--- a/src/test/regress/expected/opr_sanity.out
+++ b/src/test/regress/expected/opr_sanity.out
@@ -369,11 +369,12 @@ WHERE 'cstring'::regtype = ANY (p1.proargtypes)
     AND NOT EXISTS(SELECT 1 FROM pg_conversion WHERE conproc = p1.oid)
     AND p1.oid != 'shell_in(cstring)'::regprocedure
 ORDER BY 1;
- oid  |   proname    
-------+--------------
+ oid  |               proname                
+------+--------------------------------------
  2293 | cstring_out
  2501 | cstring_send
-(2 rows)
+ 6122 | pg_global_deadlock_check_from_remote
+(3 rows)
 
 -- Likewise, look for functions that return cstring and aren't datatype output
 -- functions nor typmod output functions.
